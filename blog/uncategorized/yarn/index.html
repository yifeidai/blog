<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="Yifei Dai">
    
    
    
    
    
    
    <title>yarn | blog</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E6%9A%AE%E8%89%B2%E7%9A%84%E5%9B%9E%E5%BF%86%20%E7%89%B9%E8%AE%AD%E5%89%8D.png " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">floatdaiの部落格</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E6%9A%AE%E8%89%B2%E7%9A%84%E5%9B%9E%E5%BF%86%20%E7%89%B9%E8%AE%AD%E5%89%8D.png');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E6%9A%AE%E8%89%B2%E7%9A%84%E5%9B%9E%E5%BF%86%20%E7%89%B9%E8%AE%AD%E5%89%8D.png');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">floatdaiの部落格</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            <div class="cube-article">
    <h1 class="title">yarn</h1>
    
    <div class="cube-article-header">
        <div class="cube-article-date">
            <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
            <!-- moment.js对象 -->
            2021-09-06
        </div>
        <div class="cube-article-tags">
    <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
    
    <a href="/tags/yarn/">#yarn</a>
    
    <a href="/tags/Plug-n-Play/">#Plug&#39;n&#39;Play</a>
    
    <a href="/tags/Zero-Installs/">#Zero-Installs</a>
    
</div>
    </div>
    
    <div class="cube-article-content cube-markdown">
        
        <h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>太古时期，npm 无道，众 JS 开发者苦 npm 久矣。npm 承平已久，不思进取。</p>
<p>这里就历数一下 npm 当年的几大原罪</p>
<ul>
<li>速度慢</li>
<li>解析出来的依赖列表不稳定</li>
<li>安全性差</li>
<li>树状的安装结构</li>
<li>命令行输出极其难懂</li>
<li>…</li>
</ul>
<p>故开源社区揭竿而起。其中的佼佼者就是 facebook 的 yarn。</p>
<h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>针对上述的缺点，yarn 进行了一系列的改进</p>
<ul>
<li>使用 yarn.lock 文件稳定构建的版本</li>
<li>每次安装依赖使用 checksum 检查</li>
<li>使用扁平的安装结构</li>
<li>支持 workspace</li>
<li>易懂的命令行输出</li>
<li>…</li>
</ul>
<p>当然以上这些优化在 yarn 的鞭策之下，npm 也同样进行了改进</p>
<ul>
<li>使用 package-lock.json 文件稳定构建的版本</li>
<li>每次安装依赖使用 SHA-512 检查</li>
<li>…</li>
</ul>
<p>不过，yarn 还是有一个相对于 npm 无可比拟的优势。yarn 的安装是并行的，而 npm 的安装是串行的。也就是说 npm 在安装完一个包后才能安装下一个包，而 yarn 可以同时安装多个包。</p>
<h2 id="一些有用的-yarn-的小知识"><a href="#一些有用的-yarn-的小知识" class="headerlink" title="一些有用的 yarn 的小知识"></a>一些有用的 yarn 的小知识</h2><h3 id="yarn-why"><a href="#yarn-why" class="headerlink" title="yarn why"></a>yarn why</h3><p>可以知道具体某一个包为何被安装</p>
<h3 id="yarn-upgrade-interactive"><a href="#yarn-upgrade-interactive" class="headerlink" title="yarn upgrade-interactive"></a>yarn upgrade-interactive</h3><p>使用可视化的界面来选择所有的依赖是否升级</p>
<h3 id="yarn-link"><a href="#yarn-link" class="headerlink" title="yarn link"></a>yarn link</h3><p>用于本地包的开发，将本地的一个文件夹作为一个包，然后可以被另一个项目进行使用</p>
<h3 id="yarn-bin"><a href="#yarn-bin" class="headerlink" title="yarn bin"></a>yarn bin</h3><p>可执行文件安装的位置，yarn 的 bin 目录经常不在 PATH 中被设置，所以我们可以在 .bashrc 文件中加入 <code>PATH=&quot;$PATH:(yarn global bin)&quot;</code> 来使通过 yarn 全局安装的文件可以被直接执行</p>
<h3 id="全局的缓存文件夹"><a href="#全局的缓存文件夹" class="headerlink" title="全局的缓存文件夹"></a>全局的缓存文件夹</h3><p>yarn 的文件下载后是先会被存在一个缓存的文件夹下，然后再拷贝进入 node_modules 目录，这个文件夹可以通过 <code>yarn cache dir</code> 命令找到。当一个文件已经被安装过，再次通过 <code>yarn</code> 这个命令进行安装，那么将不会通过网络下载这个包，而是直接从缓存中拷贝进入 node_modules 目录</p>
<h3 id="offline-mode"><a href="#offline-mode" class="headerlink" title="offline mode"></a>offline mode</h3><p>有时候，我们如果不希望通过网络下载包，比如在弱网环境，或者由于公司原因的网络隔离等等。我们就可以开启 offline mode</p>
<p>在当前项目目录下新建 <code>.yarnrc</code> 文件</p>
<pre><code>yarn-offline-mirror &quot;./npm-packages-offline-cache&quot;
yarn-offline-mirror-pruning true</code></pre><p>这样我们就开启了 offline mode</p>
<p>这时候，如果我们运行 <code>yarn</code> 命令，我们会发现在 npm-packages-offline-cache 目录下多了和全局缓存文件夹下一样的缓存文件<br>这时候我们再删除 node_modules 文件夹，断开网络，然后再执行 yarn 命令，我们仍然可以正常运行</p>
<h2 id="yarn2"><a href="#yarn2" class="headerlink" title="yarn2"></a>yarn2</h2><p>随着越来越多的新功能的加入，yarn 原来的架构无法满足新需求，所以 yarn 推出了 v2 版本。他们做出了以下的变动</p>
<ul>
<li>从 flow 迁移到 ts 进行开发</li>
<li>使用基于插件和模块化的代码架构，让开发者不用理解 yarn 的核心代码就可以通过插件的方式为 yarn 增加新功能</li>
</ul>
<p>他也引入了不少新的功能和改进</p>
<h3 id="更友好的输出信息"><a href="#更友好的输出信息" class="headerlink" title="更友好的输出信息"></a>更友好的输出信息</h3><p><img src="https://floatdai-blog.oss-cn-beijing.aliyuncs.com/yarn%E5%91%BD%E4%BB%A4%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>我们可以看到，每行日志开头都有了错误码，我们可以快速的通过 <a href="https://next.yarnpkg.com/advanced/error-codes" target="_blank" rel="noopener">错误码文档</a> 定位到问题。<br>对于每个包的操作关联到了一起，同时还各自高亮了包的名字和版本号</p>
<h3 id="更好的-workspace-支持"><a href="#更好的-workspace-支持" class="headerlink" title="更好的 workspace 支持"></a>更好的 workspace 支持</h3><p>yarn2 将 workspace 变成了一等公民，这样可以更好的支持 Monorepository。也就是一个项目空间中包含多个小的不同的包。比如 babel 就是一个例子。</p>
<p>他提供了以下便利的功能</p>
<ul>
<li>yarn add interactive mode，使用<code>yarn add xxx -i</code>，其他 workspace 可能已经使用了这个包的某个版本，可以让用户选择是否复用</li>
<li><code>yarn up</code>： 一次更新所有 workspace 下的版本，同样也具有 interactive mode</li>
<li>更好的发布流程体验</li>
<li><code>yarn workspaces foreach</code>： 所有 workspace 运行同一个命令</li>
<li><a href="https://next.yarnpkg.com/features/constraints" target="_blank" rel="noopener">contraints</a>，给所有 workspace 增加一些约束规则，这样可以通过命令来检查 workspace 是否违反了这些规则</li>
<li>像搜索数据库一样查询workspaces的依赖信息，可以使用 <code>yarn constraints query</code> 命令查询 workspace 用到的依赖信息</li>
</ul>
<h3 id="yarn-dlx"><a href="#yarn-dlx" class="headerlink" title="yarn dlx"></a>yarn dlx</h3><p><code>yarn dlx</code> 是 (download and execute) 的简称，他相当于 npx 的功能，将下载一个脚本并运行这个脚本。由于有缓存的原因，当执行过一次 <code>yarn dlx</code> 后再次执行会使用缓存的文件，速度会更快。</p>
<h3 id="Normalized-shell"><a href="#Normalized-shell" class="headerlink" title="Normalized shell"></a>Normalized shell</h3><p>yarn2 对 Windows 开发环境做了更好的兼容。我们经常会遇到这样一个问题。一个脚本在 Mac 或 linux 环境中可以正常运行，但是在 Windows 上却无法正常运行。这也是我将开发环境迁移到 wsl 的原因。但是 yarn2 自带了一个简单的 shell 解析器，覆盖了90%常用的shell脚本写法，可以让脚本在 Windows 和其他系统中一样正常运行。</p>
<h3 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a><a href="https://next.yarnpkg.com/features/protocols" target="_blank" rel="noopener">Protocols</a></h3><p>在 package.json 中 dependencies 和 devDependencies 字段中，我们可以定义我们的依赖，其中 key 是包名，而 value 指就涉及到了如何解析这个包。protocols 就是约定这个 value 值的语义是如何的</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>例子</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Semver</td>
<td>^1.2.3</td>
<td>Resolves from the default registry</td>
</tr>
<tr>
<td>Tag</td>
<td>latest</td>
<td>Resolves from the default registry</td>
</tr>
<tr>
<td>Npm alias</td>
<td>npm:name@…</td>
<td>Resolves from the npm registry</td>
</tr>
<tr>
<td>Git</td>
<td><a href="mailto:git@github.com">git@github.com</a>:foo/bar.git</td>
<td>Downloads a public package from a Git repository</td>
</tr>
<tr>
<td>GitHub</td>
<td>github:foo/bar</td>
<td>Downloads a public package from GitHub</td>
</tr>
<tr>
<td>GitHub</td>
<td>foo/bar</td>
<td>Alias for the github: protocol</td>
</tr>
<tr>
<td>File</td>
<td>file:./my-package</td>
<td>Copies the target location into the cache</td>
</tr>
<tr>
<td>Link</td>
<td>link:./my-folder</td>
<td>Creates a link to the ./my-folder folder (ignore dependencies)</td>
</tr>
<tr>
<td>Patch</td>
<td>patch:<a href="mailto:left-pad@1.0.0">left-pad@1.0.0</a>#./my-patch.patch</td>
<td>Creates a patched copy of the original package</td>
</tr>
<tr>
<td>Portal</td>
<td>portal:./my-folder</td>
<td>Creates a link to the ./my-folder folder (follow dependencies)</td>
</tr>
<tr>
<td>Workspace</td>
<td>workspace:*</td>
<td>Creates a link to a package in another workspace</td>
</tr>
<tr>
<td>Exec</td>
<td>exec:./my-generator-package</td>
<td>Experimental &amp; Plugin. Instructs Yarn to execute the specified Node script and use its output as package content</td>
</tr>
</tbody></table>
<p>link 和 portal 的区别？</p>
<p>他们都是指向本地文件系统中的一个 symlink。但是当那个指向的包中包含 package.json 文件的时候，yarn 会解析这个包中的 transitive dependencies（也就是依赖的依赖）</p>
<h3 id="Zero-Installs"><a href="#Zero-Installs" class="headerlink" title="Zero-Installs"></a>Zero-Installs</h3><p>这是 yarn2 带来的一种新的理念。我们平时都会使用 <code>yarn</code> 安装，但是 Zero-Install 是指当你从 git 拉取别人的代码后，你无需运行 <code>yarn</code> 命令即可立即运行。</p>
<p>在开发的时候，我们经常会碰到一个问题，拉取代码后由于别人引入了一个新的依赖就无法运行了。这就可以解决这个问题</p>
<p>yarn2 认为，根据墨菲定律，任何可能出问题的东西最终都可能会出问题。比如 yarn 出了 bug，网络环境有问题等等。所以为了防止这个，我们就最好运行最少量的代码。</p>
<h3 id="Zip-loading"><a href="#Zip-loading" class="headerlink" title="Zip loading"></a>Zip loading</h3><p>我们想要实现 Zero-Installs，就必然会面临一个问题一个问题，node_modules 中有海量的文件，巨量的文件让我们不可能把这些文件推送的远程。所以 yarn2 把每个包都各自压缩成了一个 .zip 的文件，PnP 的 runtime(.pnp.cjs) patch 了 fs 模块，让我们可以访问 Zip 文件中打包的文件。</p>
<h2 id="PnP-Plug’n’Play"><a href="#PnP-Plug’n’Play" class="headerlink" title="PnP(Plug’n’Play)"></a>PnP(Plug’n’Play)</h2><p>这个功能我觉得是 yarn2 主推的一个新功能，也是和我们日常开发最息息相关，提升体验巨大的一个功能。所以我单独分开来讲他。就是通过 PnP 实现了之前提到的理念 Zero-Installs。当然如果你不同意这个理念，你也可以通过一些设置关闭它。总得来说，他大幅度的提升了打包的速度。</p>
<h3 id="node-modules-的问题"><a href="#node-modules-的问题" class="headerlink" title="node_modules 的问题"></a>node_modules 的问题</h3><p>我们平时的 <code>yarn</code> 命令执行后会生成一个 node_modules 文件夹。通过 node 的 resolve 算法，我们可以使用 node_modules 中按照的包。但是因为很多原因，这个过程非常的低效：</p>
<ul>
<li>node_modules 文件夹中包含海量的文件。<code>yarn</code> 命令中超过 70% 的时间都是花在这个文件夹上面。即使有了已经安装的文件也不行，包管理器要检查当前目录中的文件和最终文件的差异</li>
<li>由于生产 node_modules 文件夹是一个重 IO 的操作，所以包管理器没有太多的余地去优化他，因为他只是做了拷贝文件的操作</li>
<li>node 并没有包的概念。他并不知道一个文件是否要被使用。完全可能出现这样的情况，在本地开发环境你的代码可以正常运行，但是由于在忘记向 package.json 文件中添加某个依赖，导致你的项目不能运行了</li>
<li>即使在运行时，node 也需要进行许多访问文件的操作去找出这个文件的实际位置在哪里（因为导入依赖时写的路径可以有多种解析的结果，node会一一尝试），这很浪费时间</li>
<li>node_modules 的设计让包管理器很好的去减少重复包的引入（多个依赖的依赖是同一个包）。即使一些算法可以优化树状的文件结构（把所有的依赖都提升到最高级的目录），但是我们仍然可能会无法优化某些特定的情形，从而导致占用更多的存储空间，同一个包出现多次。</li>
</ul>
<h3 id="pnpm-解决-node-modules-问题的尝试"><a href="#pnpm-解决-node-modules-问题的尝试" class="headerlink" title="pnpm 解决 node_modules 问题的尝试"></a><a href="https://pnpm.io/" target="_blank" rel="noopener">pnpm</a> 解决 node_modules 问题的尝试</h3><p>这里先不说 yarn 是怎么解决这个问题的，我们先来看看社区的一些其他的解决方案，pnpm 就是这样的一个库。他也是一个包管理的库。</p>
<p>他和 yarn 以及 npm 不同，他的 node_modules 的文件夹结构仍然是树形的。这样做有一个好处，就是我们访问 node_modules 下的包时，我们就仅仅可以访问我们添加在 package.json 的依赖中的包，而不像 yarn 和 npm 一样，提升到最高层级的依赖的依赖也可以访问。</p>
<p>但是这样就有一个我们之前提到过的问题，当多个包依赖同一个包，或者同一个包的不同版本时，会大量增加磁盘的使用。为了解决这个问题，pnpm 在存储多个不同版本的同一个包时，仅仅会多存储那些发生改变过的文件。就比如对于一个包的 v1 和 v2，他们各自有 100 个文件，其中 99 个文件内容相同，1 个文件不同，pnpm 只会存储 101 个文件，99 个相同的文件，和两个版本各自 不同的文件。</p>
<p>除此之外所有项目的依赖的文件都将存储于同一个位置，他们通过 hard link 的方式存放到各自项目的 node_modules 文件夹下。</p>
<h3 id="PnP-的解决方式"><a href="#PnP-的解决方式" class="headerlink" title="PnP 的解决方式"></a>PnP 的解决方式</h3><p>yarn 知道依赖的包的安装位置，不仅如此，他还负责安装这些包。所以，为什么不是由 yarn 来负责定位寻找和管理依赖的安装位置呢？</p>
<p>从 yarn2.0 开始，yarn 会生成一个 .pnp.cjs 的文件，这个文件包含了以下两个映射关系：</p>
<ul>
<li>某个特定版本包名字映射他的安装位置</li>
<li>某个特定版本包名字映射他所有的子依赖的特定版本的包名字</li>
</ul>
<p>通过这些信息， yarn 可以告诉 node 应该在哪里找到某一个包，只要他们是依赖树的一部分。所有的包都被安装在 <code>.yarn/cahce</code> 文件夹中。每个包都是一个 .zip 的文件。所以文件的数量大大减少，可以提交到 git 仓库，实现 Zero-Installs。通过 zip loading 的特性，我们可以访问这些 zip 文件。</p>
<p>这个解决方式有以下的优点</p>
<ul>
<li>安装几乎是瞬时的，yarn 只需要生成一个文件而不是原来的成千上万的文件。主要的瓶颈由原来的磁盘性能变成了依赖的数量</li>
<li>由于减少了 IO 操作的数量，安装过程变的更加可靠。尤其是在 Windows 上，批量读写文件可能因为类似 Windows Defender 的工具引起未知的错误。node_modules 的重 IO 操作更可能会导致失败</li>
<li>对于依赖树完美的优化</li>
<li>生成的 pnp.cjs 文件可以被提交到你的仓库作为 Zero-Installs 的一部分</li>
<li>应用启动速度更快。node resolution 不需要像之前一样遍历整个文件系统</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>无论是在 yarn1 还是在 yarn2 中都可以使用 pnp 特性。</p>
<h4 id="yarn1"><a href="#yarn1" class="headerlink" title="yarn1"></a>yarn1</h4><p>首先，你需要 yarn 1.12+ 版本</p>
<p>然后只需执行以下命令即可开启 PnP 特性</p>
<pre><code>yarn --pnp</code></pre><h4 id="yarn2-1"><a href="#yarn2-1" class="headerlink" title="yarn2"></a>yarn2</h4><p>yarn2 和 yarn1 不同。对于每一个单独的项目，都需要指定并锁定使用的 yarn 的版本。</p>
<p>这也是一个可以理解的事情。我们的项目是会在不同的环境上运行的，这些环境可能各自安装了不同版本的 yarn。这些 yarn 的版本之间完全可能会存在一定的 break changes。所以说，为了保证项目的稳定性，不仅仅依赖的版本应该被锁定，yarn 这个依赖管理工具的版本也应该被锁定。</p>
<p>我们先运行以下命令设定 yarn 的版本</p>
<pre><code>yarn set version berry</code></pre><p>当然我们也可以把 berry 换成其他的值，来设定成其他的版本。</p>
<p>然后初始化 yarn 设置</p>
<pre><code>yarn init</code></pre><p>在 gitignore 文件中加入一下代码</p>
<pre><code>.yarn/*
!.yarn/cache
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions</code></pre><p>最后就可以通过 <code>yarn add</code> 安装依赖了。</p>
<h3 id="生成的文件说明"><a href="#生成的文件说明" class="headerlink" title="生成的文件说明"></a>生成的文件说明</h3><ul>
<li>.yarn/cache 和 .pnp.*：这两个可以被 gitignore，但是这就丧失了 Zero-Installs 的功能。.yarn/cahce 是包保存的位置，.pnp.* 是运行时文件，保存了包存储位置的映射信息</li>
<li>yarn/install-state.gz：这是一个不需要被 commit 的优化文件，他保存了你当前项目的状态，如果你运行下一个命令的时候，通过他可以节省一些时间</li>
<li>.yarn/patches: 保存了通过 <code>yarn patch-commit</code> 命令生产的 patchfiles</li>
<li>.yarn/plugins，.yarn/releases：分别保存了我们在这个项目中引入的 yarn 插件以及我们使用 <code>yarn set version</code> 命令指定的管理当前项目的 yarn 的版本的源文件。这保证了我们在不同环境运行时使用的 yarn 都是一致的</li>
<li>.yarn/sdks：这里保存了由 <code>@yarnpkg/sdks</code> 生成的编辑器要用的 sdk，这个可以被 gitignore，不过这样你克隆项目的时候就需要重新安装这些 sdk</li>
<li>.yarn/unplugged：这个文件夹保存了经过 unplug 之后的包</li>
<li>.yarn/versions：被 <a href="https://yarnpkg.com/features/release-workflow" target="_blank" rel="noopener">version plugin</a> 使用存储一些包的发布信息</li>
<li>yarn.lock：保证各个包的版本以及下载位置的稳定</li>
<li>.yarnrc.yml：本项目 yarn 的配置文件</li>
</ul>
<h3 id="使用全局缓存"><a href="#使用全局缓存" class="headerlink" title="使用全局缓存"></a>使用全局缓存</h3><p>在 <code>.yarnrc.yml</code> 文件中加入以下配置</p>
<pre><code>enableGlobalCache: true</code></pre><p>这时，我们的依赖将不会被拷贝到本项目的 <code>.yarn/cache</code> 文件夹下，而是直接使用 yarn 的全局缓存文件夹</p>
<h3 id="pnp-loose-mode"><a href="#pnp-loose-mode" class="headerlink" title="pnp loose mode"></a>pnp loose mode</h3><p>我们知道，yarn 在 node_modules 目录中把属性结构的依赖树拉平成了单层的依赖列表，但是这个行为的结果是非标准化的且不稳定的，也就是说同一个依赖的结果运行多次是不稳定的。所以 PnP 禁止 require 那些不在 package.json 文件中的依赖。也就是说依赖的依赖是默认禁止被 require 的。但是，某些包可能会由此引发一些问题。</p>
<p>为了解决这个问题，yarn 推出了 loose mode。我们会生成一个 fallback pool，这个 pool 中包含了所有被提升到顶部的依赖。当我们 require 的东西不在依赖列表之中，我们会在 fallback pool 中寻找这个依赖。由于被提升到顶部的依赖的版本是不确定的，所以我们会报一个 warning。</p>
<p>要开启 loose mode，只需要在 <code>.yarnrc.yml</code> 文件中加入一下代码即可。</p>
<pre><code>pnpMode: loose</code></pre><p>除此之外，要确保 <code>.yarnrc.yml</code> 文件中 <code>nodeLinker: &quot;pnp&quot;</code> 设置没有被修改（这是默认值）</p>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><p>由于 pnp 特性开启后，对于依赖的寻找是由 yarn 负责而不能直接由 node 负责，所以说在运行 node 脚本的时候不能直接通过 <code>node xxx.js</code> 来运行，否则可能会找不到依赖包的位置，需要引入pnp.cjs这个文件。可以由以下几个方法代替</p>
<ul>
<li>执行 <code>yarn node xxx.js</code></li>
<li>在要执行的脚本开头加入一行 <code>require(&quot;./.pnp.cjs&quot;).setup()</code> 的代码</li>
<li>执行 <code>node -r ./.pnp.cjs ./xxx.js</code></li>
<li>执行 <code>NODE_OPTIONS=&quot;--require $(pwd)/.pnp.cjs&quot; node ./xxx.js</code></li>
</ul>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>目前大多数包都可以兼容 PnP 特性，但是仍然有一些例外。</p>
<p>其中 webpack4.x 可以通过 <a href="https://github.com/arcanis/pnp-webpack-plugin" target="_blank" rel="noopener">pnp-webpack-plugin</a> 兼容。</p>
<p>以下是一些常见的但是不兼容的包的列表</p>
<ul>
<li>angular</li>
<li>flow</li>
<li>react native</li>
<li>pulumi</li>
<li>VSCode Extension Manager</li>
<li>Hugo</li>
<li>ReScript</li>
</ul>
<p>不过这并不意味着你在使用这些包的时候你就不能使用 PnP 了。你可以使用 <a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-nm" target="_blank" rel="noopener">node-modules plugin</a>，具体操作流程可以看这个<a href="https://yarnpkg.com/getting-started/migration#if-required-enable-the-node-modules-plugin" target="_blank" rel="noopener">教程</a></p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a><a href="https://yarnpkg.com/features/pnp#caveat" target="_blank" rel="noopener">缺陷</a></h3><p>由于我们在发生 resolution error 的时候发出的是 warning 而不是 error，所以应用无法捕获到。这意味着如果在一个 try/catch 中 require 一个 peer dependency，那么将报一个 warning，即使他不该这样（这里我不是很理解，照理应该是throw error，但这里只报 warning，怎么会没有影响？贴一个原文链接，可以自己领会）。唯一的 runtime 影响就是这会让人们感到困惑，但是我们可以安全的忽略他。</p>
<h3 id="yarn-unplug"><a href="#yarn-unplug" class="headerlink" title="yarn unplug"></a>yarn unplug</h3><p>这个命令用于调试第三方包，以 lodash 为例，我们运行 <code>yarn unplug lodash</code>，lodash 包将从 <code>.yarn/cache</code> 文件夹下消失，转移到 <code>.yarn/unplugged</code> 文件夹下，并且文件由原来的 .zip 格式变成一个正常的文件夹，这样我们可以直接修改这个文件夹中的内容对第三方包进行调试。</p>
<p>除此之外，将会在 <code>package.json</code> 文件中新增一段配置</p>
<pre><code>&quot;dependenciesMeta&quot;: {
  &quot;lodash@4.17.21&quot;: {
    &quot;unplugged&quot;: true
  }
}</code></pre><p>如果调试完之后想要取消，在 <code>package.json</code> 文件中删除这段配置，然后执行 <code>yarn</code> 命令即可</p>

    </div>
</div>

<div class="cube-article-nav">
    <ul>
        
        
        <li class="next">
            <a href="/blog/js/webpack5%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/">
                webpack5迁移记录
                <i class="cube-icon cube-next" aria-hidden="true"></i>
            </a>
        </li>
        
    </ul>
</div>


<!-- TODO 根据theme.comment的内容进行入口选择 -->



        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>Yifei Dai</span>
    
    
    <div class="count">
        <a class="count articles"><span>21</span>Article</a>
        <a class="count tags"><span>28</span>Tags</a>
        <a class="count categories"><span>7</span>Categories</a>
    </div>
</div>





<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/blog/uncategorized/yarn/" title="yarn">yarn</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/blog/js/webpack5%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/" title="webpack5迁移记录">webpack5迁移记录</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/blog/uncategorized/wsl2%E8%B8%A9%E5%9D%91/" title="wsl踩坑">wsl踩坑</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/blog/uncategorized/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="JS垃圾回收机制">JS垃圾回收机制</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/blog/canvas/Canvas-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/" title="Canvas 的几个坑">Canvas 的几个坑</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/canvas/">#canvas</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/HTML/">#HTML</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/CSS/">#CSS</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/git/">#git</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/js/">#js</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/code/">#code</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/webpack/">#webpack</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/tags/canvas/">#canvas</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Hugo/">#Hugo</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Vue/">#Vue</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/CSS/">#CSS</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/CSS-Variables/">#CSS Variables</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/git/">#git</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/js/">#js</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/JS/">#JS</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/AMD/">#AMD</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/CMD/">#CMD</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/UMD/">#UMD</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/ES6-MODULE/">#ES6 MODULE</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/webpack/">#webpack</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/SVG/">#SVG</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E6%AD%A3%E5%88%99/">#正则</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/%E8%B7%A8%E5%9F%9F/">#跨域</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/stylus/">#stylus</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/css/">#css</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/unicode/">#unicode</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/utf-8/">#utf-8</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/yarn/">#yarn</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Plug-n-Play/">#Plug&#39;n&#39;Play</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Zero-Installs/">#Zero-Installs</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Web-Component/">#Web Component</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/AST/">#AST</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/CSS-in-JS/">#CSS in JS</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/CSS-module/">#CSS module</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/BEM/">#BEM</a>
        </div>
        
    </div>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 Yifei Dai

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>