<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="Yifei Dai">
    
    
    
    
    
    
    <title>blog</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E6%9A%AE%E8%89%B2%E7%9A%84%E5%9B%9E%E5%BF%86%20%E7%89%B9%E8%AE%AD%E5%89%8D.png " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">floatdaiの部落格</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E6%9A%AE%E8%89%B2%E7%9A%84%E5%9B%9E%E5%BF%86%20%E7%89%B9%E8%AE%AD%E5%89%8D.png');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E6%9A%AE%E8%89%B2%E7%9A%84%E5%9B%9E%E5%BF%86%20%E7%89%B9%E8%AE%AD%E5%89%8D.png');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">floatdaiの部落格</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-yarn">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/uncategorized/yarn/">yarn</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-09-06
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/yarn/" class="cube-excerpt-tag-link">#yarn</a>
                
                <a href="/tags/Plug-n-Play/" class="cube-excerpt-tag-link">#Plug&#39;n&#39;Play</a>
                
                <a href="/tags/Zero-Installs/" class="cube-excerpt-tag-link">#Zero-Installs</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>太古时期，npm 无道，众 JS 开发者苦 npm 久矣。npm 承平已久，不思进取。</p>
<p>这里就历数一下 npm 当年的几大原罪</p>
<ul>
<li>速度慢</li>
<li>解析出来的依赖列表不稳定</li>
<li>安全性差</li>
<li>树状的安装结构</li>
<li>命令行输出极其难懂</li>
<li>…</li>
</ul>
<p>故开源社区揭竿而起。其中的佼佼者就是 facebook 的 yarn。</p>
<h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>针对上述的缺点，yarn 进行了一系列的改进</p>
<ul>
<li>使用 yarn.lock 文件稳定构建的版本</li>
<li>每次安装依赖使用 checksum 检查</li>
<li>使用扁平的安装结构</li>
<li>支持 workspace</li>
<li>易懂的命令行输出</li>
<li>…</li>
</ul>
<p>当然以上这些优化在 yarn 的鞭策之下，npm 也同样进行了改进</p>
<ul>
<li>使用 package-lock.json 文件稳定构建的版本</li>
<li>每次安装依赖使用 SHA-512 检查</li>
<li>…</li>
</ul>
<p>不过，yarn 还是有一个相对于 npm 无可比拟的优势。yarn 的安装是并行的，而 npm 的安装是串行的。也就是说 npm 在安装完一个包后才能安装下一个包，而 yarn 可以同时安装多个包。</p>
<h2 id="一些有用的-yarn-的小知识"><a href="#一些有用的-yarn-的小知识" class="headerlink" title="一些有用的 yarn 的小知识"></a>一些有用的 yarn 的小知识</h2><h3 id="yarn-why"><a href="#yarn-why" class="headerlink" title="yarn why"></a>yarn why</h3><p>可以知道具体某一个包为何被安装</p>
<h3 id="yarn-upgrade-interactive"><a href="#yarn-upgrade-interactive" class="headerlink" title="yarn upgrade-interactive"></a>yarn upgrade-interactive</h3><p>使用可视化的界面来选择所有的依赖是否升级</p>
<h3 id="yarn-link"><a href="#yarn-link" class="headerlink" title="yarn link"></a>yarn link</h3><p>用于本地包的开发，将本地的一个文件夹作为一个包，然后可以被另一个项目进行使用</p>
<h3 id="yarn-bin"><a href="#yarn-bin" class="headerlink" title="yarn bin"></a>yarn bin</h3><p>可执行文件安装的位置，yarn 的 bin 目录经常不在 PATH 中被设置，所以我们可以在 .bashrc 文件中加入 <code>PATH=&quot;$PATH:(yarn global bin)&quot;</code> 来使通过 yarn 全局安装的文件可以被直接执行</p>
<h3 id="全局的缓存文件夹"><a href="#全局的缓存文件夹" class="headerlink" title="全局的缓存文件夹"></a>全局的缓存文件夹</h3><p>yarn 的文件下载后是先会被存在一个缓存的文件夹下，然后再拷贝进入 node_modules 目录，这个文件夹可以通过 <code>yarn cache dir</code> 命令找到。当一个文件已经被安装过，再次通过 <code>yarn</code> 这个命令进行安装，那么将不会通过网络下载这个包，而是直接从缓存中拷贝进入 node_modules 目录</p>
<h3 id="offline-mode"><a href="#offline-mode" class="headerlink" title="offline mode"></a>offline mode</h3><p>有时候，我们如果不希望通过网络下载包，比如在弱网环境，或者由于公司原因的网络隔离等等。我们就可以开启 offline mode</p>
<p>在当前项目目录下新建 <code>.yarnrc</code> 文件</p>
<pre><code>yarn-offline-mirror &quot;./npm-packages-offline-cache&quot;
yarn-offline-mirror-pruning true</code></pre><p>这样我们就开启了 offline mode</p>
<p>这时候，如果我们运行 <code>yarn</code> 命令，我们会发现在 npm-packages-offline-cache 目录下多了和全局缓存文件夹下一样的缓存文件<br>这时候我们再删除 node_modules 文件夹，断开网络，然后再执行 yarn 命令，我们仍然可以正常运行</p>
<h2 id="yarn2"><a href="#yarn2" class="headerlink" title="yarn2"></a>yarn2</h2><p>随着越来越多的新功能的加入，yarn 原来的架构无法满足新需求，所以 yarn 推出了 v2 版本。他们做出了以下的变动</p>
<ul>
<li>从 flow 迁移到 ts 进行开发</li>
<li>使用基于插件和模块化的代码架构，让开发者不用理解 yarn 的核心代码就可以通过插件的方式为 yarn 增加新功能</li>
</ul>
<p>他也引入了不少新的功能和改进</p>
<h3 id="更友好的输出信息"><a href="#更友好的输出信息" class="headerlink" title="更友好的输出信息"></a>更友好的输出信息</h3><p><img src="https://floatdai-blog.oss-cn-beijing.aliyuncs.com/yarn%E5%91%BD%E4%BB%A4%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>我们可以看到，每行日志开头都有了错误码，我们可以快速的通过 <a href="https://next.yarnpkg.com/advanced/error-codes" target="_blank" rel="noopener">错误码文档</a> 定位到问题。<br>对于每个包的操作关联到了一起，同时还各自高亮了包的名字和版本号</p>
<h3 id="更好的-workspace-支持"><a href="#更好的-workspace-支持" class="headerlink" title="更好的 workspace 支持"></a>更好的 workspace 支持</h3><p>yarn2 将 workspace 变成了一等公民，这样可以更好的支持 Monorepository。也就是一个项目空间中包含多个小的不同的包。比如 babel 就是一个例子。</p>
<p>他提供了以下便利的功能</p>
<ul>
<li>yarn add interactive mode，使用<code>yarn add xxx -i</code>，其他 workspace 可能已经使用了这个包的某个版本，可以让用户选择是否复用</li>
<li><code>yarn up</code>： 一次更新所有 workspace 下的版本，同样也具有 interactive mode</li>
<li>更好的发布流程体验</li>
<li><code>yarn workspaces foreach</code>： 所有 workspace 运行同一个命令</li>
<li><a href="https://next.yarnpkg.com/features/constraints" target="_blank" rel="noopener">contraints</a>，给所有 workspace 增加一些约束规则，这样可以通过命令来检查 workspace 是否违反了这些规则</li>
<li>像搜索数据库一样查询workspaces的依赖信息，可以使用 <code>yarn constraints query</code> 命令查询 workspace 用到的依赖信息</li>
</ul>
<h3 id="yarn-dlx"><a href="#yarn-dlx" class="headerlink" title="yarn dlx"></a>yarn dlx</h3><p><code>yarn dlx</code> 是 (download and execute) 的简称，他相当于 npx 的功能，将下载一个脚本并运行这个脚本。由于有缓存的原因，当执行过一次 <code>yarn dlx</code> 后再次执行会使用缓存的文件，速度会更快。</p>
<h3 id="Normalized-shell"><a href="#Normalized-shell" class="headerlink" title="Normalized shell"></a>Normalized shell</h3><p>yarn2 对 Windows 开发环境做了更好的兼容。我们经常会遇到这样一个问题。一个脚本在 Mac 或 linux 环境中可以正常运行，但是在 Windows 上却无法正常运行。这也是我将开发环境迁移到 wsl 的原因。但是 yarn2 自带了一个简单的 shell 解析器，覆盖了90%常用的shell脚本写法，可以让脚本在 Windows 和其他系统中一样正常运行。</p>
<h3 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a><a href="https://next.yarnpkg.com/features/protocols" target="_blank" rel="noopener">Protocols</a></h3><p>在 package.json 中 dependencies 和 devDependencies 字段中，我们可以定义我们的依赖，其中 key 是包名，而 value 指就涉及到了如何解析这个包。protocols 就是约定这个 value 值的语义是如何的</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>例子</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Semver</td>
<td>^1.2.3</td>
<td>Resolves from the default registry</td>
</tr>
<tr>
<td>Tag</td>
<td>latest</td>
<td>Resolves from the default registry</td>
</tr>
<tr>
<td>Npm alias</td>
<td>npm:name@…</td>
<td>Resolves from the npm registry</td>
</tr>
<tr>
<td>Git</td>
<td><a href="mailto:git@github.com">git@github.com</a>:foo/bar.git</td>
<td>Downloads a public package from a Git repository</td>
</tr>
<tr>
<td>GitHub</td>
<td>github:foo/bar</td>
<td>Downloads a public package from GitHub</td>
</tr>
<tr>
<td>GitHub</td>
<td>foo/bar</td>
<td>Alias for the github: protocol</td>
</tr>
<tr>
<td>File</td>
<td>file:./my-package</td>
<td>Copies the target location into the cache</td>
</tr>
<tr>
<td>Link</td>
<td>link:./my-folder</td>
<td>Creates a link to the ./my-folder folder (ignore dependencies)</td>
</tr>
<tr>
<td>Patch</td>
<td>patch:<a href="mailto:left-pad@1.0.0">left-pad@1.0.0</a>#./my-patch.patch</td>
<td>Creates a patched copy of the original package</td>
</tr>
<tr>
<td>Portal</td>
<td>portal:./my-folder</td>
<td>Creates a link to the ./my-folder folder (follow dependencies)</td>
</tr>
<tr>
<td>Workspace</td>
<td>workspace:*</td>
<td>Creates a link to a package in another workspace</td>
</tr>
<tr>
<td>Exec</td>
<td>exec:./my-generator-package</td>
<td>Experimental &amp; Plugin. Instructs Yarn to execute the specified Node script and use its output as package content</td>
</tr>
</tbody></table>
<p>link 和 portal 的区别？</p>
<p>他们都是指向本地文件系统中的一个 symlink。但是当那个指向的包中包含 package.json 文件的时候，yarn 会解析这个包中的 transitive dependencies（也就是依赖的依赖）</p>
<h3 id="Zero-Installs"><a href="#Zero-Installs" class="headerlink" title="Zero-Installs"></a>Zero-Installs</h3><p>这是 yarn2 带来的一种新的理念。我们平时都会使用 <code>yarn</code> 安装，但是 Zero-Install 是指当你从 git 拉取别人的代码后，你无需运行 <code>yarn</code> 命令即可立即运行。</p>
<p>在开发的时候，我们经常会碰到一个问题，拉取代码后由于别人引入了一个新的依赖就无法运行了。这就可以解决这个问题</p>
<p>yarn2 认为，根据墨菲定律，任何可能出问题的东西最终都可能会出问题。比如 yarn 出了 bug，网络环境有问题等等。所以为了防止这个，我们就最好运行最少量的代码。</p>
<h3 id="Zip-loading"><a href="#Zip-loading" class="headerlink" title="Zip loading"></a>Zip loading</h3><p>我们想要实现 Zero-Installs，就必然会面临一个问题一个问题，node_modules 中有海量的文件，巨量的文件让我们不可能把这些文件推送的远程。所以 yarn2 把每个包都各自压缩成了一个 .zip 的文件，PnP 的 runtime(.pnp.cjs) patch 了 fs 模块，让我们可以访问 Zip 文件中打包的文件。</p>
<h2 id="PnP-Plug’n’Play"><a href="#PnP-Plug’n’Play" class="headerlink" title="PnP(Plug’n’Play)"></a>PnP(Plug’n’Play)</h2><p>这个功能我觉得是 yarn2 主推的一个新功能，也是和我们日常开发最息息相关，提升体验巨大的一个功能。所以我单独分开来讲他。就是通过 PnP 实现了之前提到的理念 Zero-Installs。当然如果你不同意这个理念，你也可以通过一些设置关闭它。总得来说，他大幅度的提升了打包的速度。</p>
<h3 id="node-modules-的问题"><a href="#node-modules-的问题" class="headerlink" title="node_modules 的问题"></a>node_modules 的问题</h3><p>我们平时的 <code>yarn</code> 命令执行后会生成一个 node_modules 文件夹。通过 node 的 resolve 算法，我们可以使用 node_modules 中按照的包。但是因为很多原因，这个过程非常的低效：</p>
<ul>
<li>node_modules 文件夹中包含海量的文件。<code>yarn</code> 命令中超过 70% 的时间都是花在这个文件夹上面。即使有了已经安装的文件也不行，包管理器要检查当前目录中的文件和最终文件的差异</li>
<li>由于生产 node_modules 文件夹是一个重 IO 的操作，所以包管理器没有太多的余地去优化他，因为他只是做了拷贝文件的操作</li>
<li>node 并没有包的概念。他并不知道一个文件是否要被使用。完全可能出现这样的情况，在本地开发环境你的代码可以正常运行，但是由于在忘记向 package.json 文件中添加某个依赖，导致你的项目不能运行了</li>
<li>即使在运行时，node 也需要进行许多访问文件的操作去找出这个文件的实际位置在哪里（因为导入依赖时写的路径可以有多种解析的结果，node会一一尝试），这很浪费时间</li>
<li>node_modules 的设计让包管理器很好的去减少重复包的引入（多个依赖的依赖是同一个包）。即使一些算法可以优化树状的文件结构（把所有的依赖都提升到最高级的目录），但是我们仍然可能会无法优化某些特定的情形，从而导致占用更多的存储空间，同一个包出现多次。</li>
</ul>
<h3 id="pnpm-解决-node-modules-问题的尝试"><a href="#pnpm-解决-node-modules-问题的尝试" class="headerlink" title="pnpm 解决 node_modules 问题的尝试"></a><a href="https://pnpm.io/" target="_blank" rel="noopener">pnpm</a> 解决 node_modules 问题的尝试</h3><p>这里先不说 yarn 是怎么解决这个问题的，我们先来看看社区的一些其他的解决方案，pnpm 就是这样的一个库。他也是一个包管理的库。</p>
<p>他和 yarn 以及 npm 不同，他的 node_modules 的文件夹结构仍然是树形的。这样做有一个好处，就是我们访问 node_modules 下的包时，我们就仅仅可以访问我们添加在 package.json 的依赖中的包，而不像 yarn 和 npm 一样，提升到最高层级的依赖的依赖也可以访问。</p>
<p>但是这样就有一个我们之前提到过的问题，当多个包依赖同一个包，或者同一个包的不同版本时，会大量增加磁盘的使用。为了解决这个问题，pnpm 在存储多个不同版本的同一个包时，仅仅会多存储那些发生改变过的文件。就比如对于一个包的 v1 和 v2，他们各自有 100 个文件，其中 99 个文件内容相同，1 个文件不同，pnpm 只会存储 101 个文件，99 个相同的文件，和两个版本各自 不同的文件。</p>
<p>除此之外所有项目的依赖的文件都将存储于同一个位置，他们通过 hard link 的方式存放到各自项目的 node_modules 文件夹下。</p>
<h3 id="PnP-的解决方式"><a href="#PnP-的解决方式" class="headerlink" title="PnP 的解决方式"></a>PnP 的解决方式</h3><p>yarn 知道依赖的包的安装位置，不仅如此，他还负责安装这些包。所以，为什么不是由 yarn 来负责定位寻找和管理依赖的安装位置呢？</p>
<p>从 yarn2.0 开始，yarn 会生成一个 .pnp.cjs 的文件，这个文件包含了以下两个映射关系：</p>
<ul>
<li>某个特定版本包名字映射他的安装位置</li>
<li>某个特定版本包名字映射他所有的子依赖的特定版本的包名字</li>
</ul>
<p>通过这些信息， yarn 可以告诉 node 应该在哪里找到某一个包，只要他们是依赖树的一部分。所有的包都被安装在 <code>.yarn/cahce</code> 文件夹中。每个包都是一个 .zip 的文件。所以文件的数量大大减少，可以提交到 git 仓库，实现 Zero-Installs。通过 zip loading 的特性，我们可以访问这些 zip 文件。</p>
<p>这个解决方式有以下的优点</p>
<ul>
<li>安装几乎是瞬时的，yarn 只需要生成一个文件而不是原来的成千上万的文件。主要的瓶颈由原来的磁盘性能变成了依赖的数量</li>
<li>由于减少了 IO 操作的数量，安装过程变的更加可靠。尤其是在 Windows 上，批量读写文件可能因为类似 Windows Defender 的工具引起未知的错误。node_modules 的重 IO 操作更可能会导致失败</li>
<li>对于依赖树完美的优化</li>
<li>生成的 pnp.cjs 文件可以被提交到你的仓库作为 Zero-Installs 的一部分</li>
<li>应用启动速度更快。node resolution 不需要像之前一样遍历整个文件系统</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>无论是在 yarn1 还是在 yarn2 中都可以使用 pnp 特性。</p>
<h4 id="yarn1"><a href="#yarn1" class="headerlink" title="yarn1"></a>yarn1</h4><p>首先，你需要 yarn 1.12+ 版本</p>
<p>然后只需执行以下命令即可开启 PnP 特性</p>
<pre><code>yarn --pnp</code></pre><h4 id="yarn2-1"><a href="#yarn2-1" class="headerlink" title="yarn2"></a>yarn2</h4><p>yarn2 和 yarn1 不同。对于每一个单独的项目，都需要指定并锁定使用的 yarn 的版本。</p>
<p>这也是一个可以理解的事情。我们的项目是会在不同的环境上运行的，这些环境可能各自安装了不同版本的 yarn。这些 yarn 的版本之间完全可能会存在一定的 break changes。所以说，为了保证项目的稳定性，不仅仅依赖的版本应该被锁定，yarn 这个依赖管理工具的版本也应该被锁定。</p>
<p>我们先运行以下命令设定 yarn 的版本</p>
<pre><code>yarn set version berry</code></pre><p>当然我们也可以把 berry 换成其他的值，来设定成其他的版本。</p>
<p>然后初始化 yarn 设置</p>
<pre><code>yarn init</code></pre><p>在 gitignore 文件中加入一下代码</p>
<pre><code>.yarn/*
!.yarn/cache
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions</code></pre><p>最后就可以通过 <code>yarn add</code> 安装依赖了。</p>
<h3 id="生成的文件说明"><a href="#生成的文件说明" class="headerlink" title="生成的文件说明"></a>生成的文件说明</h3><ul>
<li>.yarn/cache 和 .pnp.*：这两个可以被 gitignore，但是这就丧失了 Zero-Installs 的功能。.yarn/cahce 是包保存的位置，.pnp.* 是运行时文件，保存了包存储位置的映射信息</li>
<li>yarn/install-state.gz：这是一个不需要被 commit 的优化文件，他保存了你当前项目的状态，如果你运行下一个命令的时候，通过他可以节省一些时间</li>
<li>.yarn/patches: 保存了通过 <code>yarn patch-commit</code> 命令生产的 patchfiles</li>
<li>.yarn/plugins，.yarn/releases：分别保存了我们在这个项目中引入的 yarn 插件以及我们使用 <code>yarn set version</code> 命令指定的管理当前项目的 yarn 的版本的源文件。这保证了我们在不同环境运行时使用的 yarn 都是一致的</li>
<li>.yarn/sdks：这里保存了由 <code>@yarnpkg/sdks</code> 生成的编辑器要用的 sdk，这个可以被 gitignore，不过这样你克隆项目的时候就需要重新安装这些 sdk</li>
<li>.yarn/unplugged：这个文件夹保存了经过 unplug 之后的包</li>
<li>.yarn/versions：被 <a href="https://yarnpkg.com/features/release-workflow" target="_blank" rel="noopener">version plugin</a> 使用存储一些包的发布信息</li>
<li>yarn.lock：保证各个包的版本以及下载位置的稳定</li>
<li>.yarnrc.yml：本项目 yarn 的配置文件</li>
</ul>
<h3 id="使用全局缓存"><a href="#使用全局缓存" class="headerlink" title="使用全局缓存"></a>使用全局缓存</h3><p>在 <code>.yarnrc.yml</code> 文件中加入以下配置</p>
<pre><code>enableGlobalCache: true</code></pre><p>这时，我们的依赖将不会被拷贝到本项目的 <code>.yarn/cache</code> 文件夹下，而是直接使用 yarn 的全局缓存文件夹</p>
<h3 id="pnp-loose-mode"><a href="#pnp-loose-mode" class="headerlink" title="pnp loose mode"></a>pnp loose mode</h3><p>我们知道，yarn 在 node_modules 目录中把属性结构的依赖树拉平成了单层的依赖列表，但是这个行为的结果是非标准化的且不稳定的，也就是说同一个依赖的结果运行多次是不稳定的。所以 PnP 禁止 require 那些不在 package.json 文件中的依赖。也就是说依赖的依赖是默认禁止被 require 的。但是，某些包可能会由此引发一些问题。</p>
<p>为了解决这个问题，yarn 推出了 loose mode。我们会生成一个 fallback pool，这个 pool 中包含了所有被提升到顶部的依赖。当我们 require 的东西不在依赖列表之中，我们会在 fallback pool 中寻找这个依赖。由于被提升到顶部的依赖的版本是不确定的，所以我们会报一个 warning。</p>
<p>要开启 loose mode，只需要在 <code>.yarnrc.yml</code> 文件中加入一下代码即可。</p>
<pre><code>pnpMode: loose</code></pre><p>除此之外，要确保 <code>.yarnrc.yml</code> 文件中 <code>nodeLinker: &quot;pnp&quot;</code> 设置没有被修改（这是默认值）</p>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><p>由于 pnp 特性开启后，对于依赖的寻找是由 yarn 负责而不能直接由 node 负责，所以说在运行 node 脚本的时候不能直接通过 <code>node xxx.js</code> 来运行，否则可能会找不到依赖包的位置，需要引入pnp.cjs这个文件。可以由以下几个方法代替</p>
<ul>
<li>执行 <code>yarn node xxx.js</code></li>
<li>在要执行的脚本开头加入一行 <code>require(&quot;./.pnp.cjs&quot;).setup()</code> 的代码</li>
<li>执行 <code>node -r ./.pnp.cjs ./xxx.js</code></li>
<li>执行 <code>NODE_OPTIONS=&quot;--require $(pwd)/.pnp.cjs&quot; node ./xxx.js</code></li>
</ul>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>目前大多数包都可以兼容 PnP 特性，但是仍然有一些例外。</p>
<p>其中 webpack4.x 可以通过 <a href="https://github.com/arcanis/pnp-webpack-plugin" target="_blank" rel="noopener">pnp-webpack-plugin</a> 兼容。</p>
<p>以下是一些常见的但是不兼容的包的列表</p>
<ul>
<li>angular</li>
<li>flow</li>
<li>react native</li>
<li>pulumi</li>
<li>VSCode Extension Manager</li>
<li>Hugo</li>
<li>ReScript</li>
</ul>
<p>不过这并不意味着你在使用这些包的时候你就不能使用 PnP 了。你可以使用 <a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-nm" target="_blank" rel="noopener">node-modules plugin</a>，具体操作流程可以看这个<a href="https://yarnpkg.com/getting-started/migration#if-required-enable-the-node-modules-plugin" target="_blank" rel="noopener">教程</a></p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a><a href="https://yarnpkg.com/features/pnp#caveat" target="_blank" rel="noopener">缺陷</a></h3><p>由于我们在发生 resolution error 的时候发出的是 warning 而不是 error，所以应用无法捕获到。这意味着如果在一个 try/catch 中 require 一个 peer dependency，那么将报一个 warning，即使他不该这样（这里我不是很理解，照理应该是throw error，但这里只报 warning，怎么会没有影响？贴一个原文链接，可以自己领会）。唯一的 runtime 影响就是这会让人们感到困惑，但是我们可以安全的忽略他。</p>
<h3 id="yarn-unplug"><a href="#yarn-unplug" class="headerlink" title="yarn unplug"></a>yarn unplug</h3><p>这个命令用于调试第三方包，以 lodash 为例，我们运行 <code>yarn unplug lodash</code>，lodash 包将从 <code>.yarn/cache</code> 文件夹下消失，转移到 <code>.yarn/unplugged</code> 文件夹下，并且文件由原来的 .zip 格式变成一个正常的文件夹，这样我们可以直接修改这个文件夹中的内容对第三方包进行调试。</p>
<p>除此之外，将会在 <code>package.json</code> 文件中新增一段配置</p>
<pre><code>&quot;dependenciesMeta&quot;: {
  &quot;lodash@4.17.21&quot;: {
    &quot;unplugged&quot;: true
  }
}</code></pre><p>如果调试完之后想要取消，在 <code>package.json</code> 文件中删除这段配置，然后执行 <code>yarn</code> 命令即可</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/uncategorized/yarn/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack5迁移记录">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/js/webpack5%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/">webpack5迁移记录</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-01
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>webpack5 已经发布了好久了，但是我们现在项目构建使用的还是 webpack4。也是时候尝试一下使用 webpack5。感受一下 webpack5 有什么新的功能和改进了。</p>
<h2 id="webpack5-相对于-webpack4-的提升"><a href="#webpack5-相对于-webpack4-的提升" class="headerlink" title="webpack5 相对于 webpack4 的提升"></a>webpack5 相对于 webpack4 的提升</h2><p><a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/#general-direction" target="_blank" rel="noopener">提升</a></p>
<ol>
<li>使用持久化缓存来提升构建性能</li>
<li>使用更好的算法和默认值来改进持久化缓存</li>
<li>使用更好的tree shaking和代码生成来减小打包的体积</li>
<li>改进web平台的兼容能力</li>
<li>在不造成breaking change的前提下改进一些遗留在webpack4中内部奇怪的结构</li>
<li>通过引入一些breaking changes来为未来的一些新需求做准备，这是为了可以尽可能长的将版本保持在v5</li>
</ol>
<h2 id="升级准备"><a href="#升级准备" class="headerlink" title="升级准备"></a>升级准备</h2><p>webpack 提供了专门的文档，<a href="https://webpack.js.org/migrate/5/" target="_blank" rel="noopener">迁移到webpack5</a>，来从v4到v5进行升级。这是在官方文档中，他们建议的迁移过程。</p>
<ol>
<li>Node.js 至少需要 10.13.0 版本</li>
<li>升级 plugin 和 loader</li>
<li>确认构建没有 error 和 warning</li>
<li>确保设置了 mode 选项</li>
<li><a href="https://webpack.js.org/migrate/5/#update-outdated-options" target="_blank" rel="noopener">更新一些过时的配置</a>，这个链接中展示了完整的过时的配置列表</li>
<li>测试 webpack5 的兼容性</li>
<li>将 webpack 的包更新到5</li>
<li><a href="https://webpack.js.org/migrate/5/#clean-up-configuration" target="_blank" rel="noopener">清理一些配置</a>，这个链接中展示了完整的迁移过程中需要注意修改的配置的列表</li>
<li>尝试构建并解决构建的问题</li>
</ol>
<h2 id="升级实践"><a href="#升级实践" class="headerlink" title="升级实践"></a>升级实践</h2><p>看了一遍文档后，就要自己尝试实践一下这个过程，看看会遇到哪些问题了。我就以自己最近正负责的一个项目为例进行尝试，对照上述的步骤进行一一的尝试。</p>
<ol>
<li>Node.js 至少需要 10.13.0 版本</li>
</ol>
<p>这一步没有任何的问题，只是升级了本地的后别忘了升级构建生产包的服务器的 Node.js 版本。</p>
<ol start="2">
<li>升级 plugin 和 loader</li>
</ol>
<p>我先运行了dev的编译命令，以下两个插件报错了，各自升级到最新版本后解决了问题</p>
<ul>
<li>vue-loader</li>
<li>webpack-dev-middleware</li>
<li>html-webpack-plugin</li>
<li>移除optimize-css-assets-webpack-plugin，使用 css-minimizer-webpack-plugin 替代</li>
</ul>
<ol start="3">
<li>确认构建没有 error 和 warning</li>
</ol>
<ul>
<li>我配置了 html-webpack-plugin 中 <code>inject: head</code>，插入的 script 标签中，自动加上了 defer 属性。所以我在 body 中手动引入的那些 script 也需要加上 defer 属性才可以保证执行顺序。</li>
</ul>
<ol start="4">
<li><p>确保设置了 mode 选项</p>
</li>
<li><p>更新一些过时的配置</p>
</li>
<li><p>测试 webpack5 的兼容性</p>
</li>
<li><p>将 webpack 的包更新到5</p>
</li>
<li><p>清理一些配置</p>
</li>
<li><p>尝试构建并解决构建的问题</p>
</li>
</ol>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/js/webpack5%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-wsl踩坑">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/uncategorized/wsl2%E8%B8%A9%E5%9D%91/">wsl踩坑</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-02-07
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>本文针对的是使用 wsl2 的开发者，记录的是我在使用 wsl 的过程中遇到的一些坑。欢迎大家一起来补充</p>
<h2 id="wsl-hot-reload-not-work"><a href="#wsl-hot-reload-not-work" class="headerlink" title="wsl hot reload not work"></a>wsl hot reload not work</h2><p><a href="https://github.com/microsoft/WSL/issues/4417#issuecomment-526279339" target="_blank" rel="noopener">https://github.com/microsoft/WSL/issues/4417#issuecomment-526279339</a></p>
<p>注：在 wsl2 中，如果打开的文件是在 /mnt 下（也就是在Windows中下载），是无法 hot reload 的，可以在 linux 子系统中下载项目</p>
<h2 id="wsl-terminal-bashrc-file"><a href="#wsl-terminal-bashrc-file" class="headerlink" title="wsl terminal .bashrc file"></a>wsl terminal .bashrc file</h2><p>Windows 和 wsl2 的命令行使用的 bashrc 不是同一个文件。Windows 的是在 Windows 的用户目录下，wsl 在 <code>~/.bashrc</code>。这两个不是一个位置。</p>
<h2 id="wsl-install-node"><a href="#wsl-install-node" class="headerlink" title="wsl install node"></a>wsl install node</h2><p><a href="https://github.com/nodejs/help/wiki/Installation#how-to-install-nodejs-via-binary-archive-on-linux" target="_blank" rel="noopener">https://github.com/nodejs/help/wiki/Installation#how-to-install-nodejs-via-binary-archive-on-linux</a></p>
<h2 id="Windows-browse-linux-file-system"><a href="#Windows-browse-linux-file-system" class="headerlink" title="Windows browse linux file system"></a>Windows browse linux file system</h2><ul>
<li><p>可以通过在地址栏中输入 <code>\\wsl$</code> 来访问</p>
</li>
<li><p>通过 wsl –mount 生成(preview 中，持续关注), <a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-mount-disk" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/wsl/wsl2-mount-disk</a></p>
</li>
</ul>
<h2 id="open-current-folder-in-terminal"><a href="#open-current-folder-in-terminal" class="headerlink" title="open current folder in terminal"></a>open current folder in terminal</h2><pre><code>explorer.exe .</code></pre><p>为了方便，可以设置 alias</p>
<pre><code>alias explorer=&quot;explorer.exe .&quot;</code></pre><h2 id="yarn-global-add-not-work"><a href="#yarn-global-add-not-work" class="headerlink" title="yarn global add not work"></a>yarn global add not work</h2><p><a href="https://stackoverflow.com/a/40333409" target="_blank" rel="noopener">https://stackoverflow.com/a/40333409</a></p>
<p>You should add <code>export PATH=&quot;$PATH:$(yarn global bin)&quot;</code> to your ~/.bash_profile or whatever you use.</p>
<h2 id="wsl-vmmem-进程内存占用过大"><a href="#wsl-vmmem-进程内存占用过大" class="headerlink" title="wsl vmmem 进程内存占用过大"></a>wsl vmmem 进程内存占用过大</h2><p>我开了4个VSCode，结果电脑内存直接炸了，一查，vmmem进程占了5G</p>
<p><a href="https://blog.n0ts.cn/1155.html" target="_blank" rel="noopener">https://blog.n0ts.cn/1155.html</a></p>
<p>win+R,输入<code>%UserProfile%</code>，会打开一个文件夹，在其中新建一个<code>.wslconfig</code>,其中输入一下内容</p>
<pre><code>[wsl2]
memory=4GB
swap=2GB
localhostForwarding=true</code></pre><p>memory为系统内存上限，可根据实际情况进行配置</p>
<p>运行<code>wsl --shutdown</code>命令，关闭wsl的运行</p>
<p>然后运行<code>wsl</code>命令，重启wsl</p>
<h2 id="wsl2-set-proxy"><a href="#wsl2-set-proxy" class="headerlink" title="wsl2 set proxy"></a>wsl2 set proxy</h2><p>因为 shadowSocks 不是运行在 wsl2 本地，所以得通过 IP 访问 Windows。Windows 的 IP 对于 wsl2 是动态的，可以通过一个脚本来获取。<br>在 <code>~/.bashrc</code> 中加入以下配置。<br>注意，在代理软件中的设置中打开 <strong>允许来自局域网的链接</strong> 选项</p>
<pre><code>export HOST_IP=$(grep -oP &#39;(?&lt;=nameserver\ ).*&#39; /etc/resolv.conf)
export PROXY_ADDR=&quot;http://$HOST_IP:1080&quot;
yarn config set proxy &quot;$PROXY_ADDR&quot;
yarn config set https-proxy &quot;$PROXY_ADDR&quot;
npm config set proxy &quot;$PROXY_ADDR&quot;
npm config set https-proxy &quot;$PROXY_ADDR&quot;
export http_proxy=$PROXY_ADDR
export https_proxy=$PROXY_ADDR</code></pre><p>如果，还是无法成功连接，可能是因为 Windows 的防火墙的原因。<br>按 win 按钮打开开始菜单，搜索 允许应用通过 Windows Defender 防火墙。更改其中的配置，寻找你的代理程序（对我是 ShadowSockR)，把所有的勾都打上。应该就可以解决了。</p>
<h2 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问"></a>局域网访问</h2><p>自动化脚本映射端口（需提前配置需要映射的端口）：<a href="https://github.com/microsoft/WSL/issues/4150#issuecomment-504209723" target="_blank" rel="noopener">https://github.com/microsoft/WSL/issues/4150#issuecomment-504209723</a></p>
<p>直接的命令：</p>
<pre><code># $addr: 0.0.0.0, $remoteport: wsl2 的内网地址，可通过 ipconfig 查看
netsh interface portproxy add v4tov4 listenport=$port listenaddress=$addr connectport=$port connectaddress=$remoteport</code></pre><h2 id="解除-windows-defender-影响"><a href="#解除-windows-defender-影响" class="headerlink" title="解除 windows defender 影响"></a>解除 windows defender 影响</h2><p><a href="https://github.com/microsoft/WSL/issues/4139#issuecomment-732067409" target="_blank" rel="noopener">https://github.com/microsoft/WSL/issues/4139#issuecomment-732067409</a></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/uncategorized/wsl2%E8%B8%A9%E5%9D%91/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-JS垃圾回收机制">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/uncategorized/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">JS垃圾回收机制</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-01-11
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/JS/" class="cube-excerpt-tag-link">#JS</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>有些语言，比如C语言，是需要程序员手动申请和释放内存的，这增加了程序员的心智负担。大多数语言都提供了自动的垃圾处理机制。JS也同样如此。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>JS 垃圾回收机制的根本就是判断一个变量是否可以被访问到。如果一个变量不可以从根上开始，由某种路径访问到的话，那么这个变量就是不可被访问的。这种情况下，JS引擎就认为这个变量是可以被垃圾回收的。</p>
<pre><code>function a() {
  const f = {}
}

function b() {
  const g = {}
  return g
}

const d = a()
const e = b()</code></pre><p>简单的举一个例子。我们看一下上述代码。</p>
<p>在执行a函数期间，变量f始终存在，因为f可以在当前的上下文环境，也就是a函数中被访问到。但是当a函数执行结束，我们的上下文环境变成了全局，这时候我们就无法通过任何方式访问到f变量了。这时候JS引擎就把e变量给释放掉了。</p>
<p>在执行b函数期间，变量g始终存在，因为g可以在当前的上下文环境，也就是b函数中被访问到。当b函数执行结束，将g作为返回值赋值给了e，所以即使上下文环境切换了，但是我们仍然可以通过变量e来访问变量g，所以变量g并不会被回收。</p>
<p>一般垃圾回收的算法是通过 标记-清除 来实现的。垃圾回收期会定时的执行这些任务。</p>
<ol>
<li>获取根并标记。 也就是我们的全局环境。</li>
<li>标记所有根可以访问到的引用。 也就是全局变量，以及各个代码块形成的局部环境。</li>
<li>标记上一步标记的引用可以访问到的引用，并不断重复这一步，直到没有新的未被标记的变量出现为止。</li>
<li>回收所有没有被标记到的变量。</li>
</ol>
<h2 id="内存泄露的原因"><a href="#内存泄露的原因" class="headerlink" title="内存泄露的原因"></a>内存泄露的原因</h2><ol>
<li>全局变量</li>
</ol>
<p>由于全局变量是直接存在根环境之中的，所以显然他是在任何情况下都不会被回收的。我们要尽可能少的使用全局变量。</p>
<p>当然有时候我们会无意中使用了全局变量，如下所示：</p>
<pre><code>function a() {
  b = 1
}</code></pre><p>在上述代码中，变量 b 将作为一个全局变量进行定义。这显然是我们不希望的。当然，现在使用linter或者开启JS的严格模式都很容易可以避免这个问题的发生。</p>
<ol start="2">
<li>闭包</li>
</ol>
<p>在某一个函数执行完后，照理这个函数环境下定义的变量都将要被回收，但是有一个情况是例外的，那就是闭包。</p>
<p>在闭包的情况下，函数中的那个变量将可以被外界所访问到，所以显然是不能被回收的。</p>
<ol start="3">
<li>忘记结束的定时器</li>
</ol>
<pre><code>setInterval(function a() {

}, 1000)</code></pre><p>这个函数a将用于不会被回收，因为这个定时器将一直被执行，所以显然不能被回收，所以我们要记住结束定时器。</p>
<pre><code>window.addEventListener(&quot;click&quot;, function a() {

})</code></pre><p>同样的，这种监听器也是如此。不能忘记 <code>removeEventListener</code>。</p>
<ol start="4">
<li>被移除的DOM</li>
</ol>
<p>大家在操作DOM的时候，有些DOM节点可能会被多次使用。这时候，我们会考虑把DOM的查询结果存在一个变量之中。因为我们都知道，DOM和JS引擎是互相独立的，JS要操作DOM是很耗性能的。那么如果之后我们把这个DOM移除了，这个DOM节点其实并没有被回收，因为他还被一个变量所引用了。</p>
<ol start="5">
<li>console.log</li>
</ol>
<p>被 console.log 所打印的变量是不会被回收的。这也很好理解，因为我们要随时可以去 console 里面看这个变量，所以当然不能被回收。所以在生产环境中，我们要尽量避免使用 console.log。一般生产环境的打包都有自动移除 console 的选项。</p>
<h2 id="如何发现内存泄露（待补图）"><a href="#如何发现内存泄露（待补图）" class="headerlink" title="如何发现内存泄露（待补图）"></a>如何发现内存泄露（待补图）</h2><p>首先第一步是要确定是否存在内存泄露的现象。我们可以靠 Chrome 提供的调试工具来做到这个。</p>
<ol>
<li>首先按 F12 打开 Chrome 的调试面板。</li>
<li>点击跳转到 Performance 这个 tab。</li>
<li>点击左上方的实心小圆球，hover 上去显示的是 record 的那个。点击这个将开始记录之后的各种性能问题的参数。</li>
<li>进行一些认为存在性能问题的操作。</li>
<li>点击 Stop 按钮。结束记录。</li>
</ol>
<p>在最上面，我们可以看到 FPS，CPU，NET，HEAP 这四个性能指标的图表图表。内存问题的话可以看 HEAP 这个。如果他的趋势是一直上升那显然就存在内存泄露。</p>
<p>详细的内容也可以给 ScreenShots 旁边的 Memory 打钩（注意不是和 Performance 同级的那个，在下一行中），打开这个新的面板。可以看到内存随着时间的使用详情。</p>
<p>但是这个工具只能记录一段时间的使用情况。Chrome 有一个工具，名字叫 Performance Monitor 可以实时的监控各种性能指标的使用情况。打开方式如下：</p>
<ol>
<li>点击调试工具最上方的最右边的 X 左边的三个点，会弹出一个 context menu</li>
<li>鼠标悬浮到这个弹出的菜单的 More tools 上，会再延伸出一个子菜单</li>
<li>点击子菜单中的 Performance Menu，将在最下方弹出 Performance Menu 菜单</li>
</ol>
<p>我们可以看到，这个菜单中有 CPU usage， JS heap size， DOM Nodes 等众多性能指标，并且在实时的进行记录。通过这个工具，我们可以更加方便的进行性能分析。</p>
<p>最后，我们就要分析到底是什么导致了内存泄露。</p>
<p>这时候，我们就要点开最上面的 Memory 这个 tab 了。</p>
<p>点开这个菜单后，点击左上角的小圆球（hover上去显示 Take heap snapshot）。点击这个后将生成一个那个时刻的内存使用情况的快照。我们可以生成多份快照，来比较不同时间之间内存使用的变化来分析哪里发生了内存泄露。当然，我们也可以点击那个垃圾桶的图标，来进行手动的触发垃圾回收。再生成新的快照来比较内存使用情况进行分析。</p>
<p>再让我们点开一份快照，看看里面有哪些信息。我们可以看到，他分成了两个窗口，上面有很多条目，下面的标题是 Retainer（可以理解成定位器），但是空无一物。</p>
<p>观察一下这些条目，发现有</p>
<ul>
<li>array</li>
<li>closure</li>
<li>compiled code</li>
<li>concatenated string</li>
<li>number</li>
<li>regexp</li>
<li>…</li>
</ul>
<p>可以看到，他把内存的使用情况进行分类的整理。随便点开一个类型，可以看到很多“变量”。他们都各自在当前实际占用了一部分内存。点击选中一个“变量”，我们可以发现，底下的那个 Retainer 窗口有值了。显示出来的是一个嵌套的结构。注意，这个嵌套结构是反的。这个嵌套的结构展示了，这个变量是如何通过root来访问到他的。也就是说最上层是自己，下层就是他自己的上级。这个结构就展示了为什么这个变量没有被回收。而且，更方便的是，在每一层的右边，有一个代码的链接，可以让你迅速的找到创建这一层上下文或者变量的代码的位置。</p>
<p>通过对这两个窗口进行分析，我们可以比较清楚的定位到发生内存泄露的位置了。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/uncategorized/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Canvas 的几个坑">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/canvas/Canvas-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/">Canvas 的几个坑</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-12-28
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/canvas/" class="cube-excerpt-tag-link">#canvas</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>最近接到公司的一个临时需求，要生成一批不同名字的邀请函。一开始我觉得这实在是太简单了，不就是canvas上贴一张图再写名字就结束了吗？但是没想到，因为不熟悉canvas导致这其中好几个坑花了我好多时间。</p>
<h2 id="fillText-参数"><a href="#fillText-参数" class="headerlink" title="fillText 参数"></a>fillText 参数</h2><p>接到这个需求，上来肯定是先去看看写字的api喽。然后我就开始测试一下。</p>
<pre><code>ctx.fillText(&quot;hello&quot;, 0, 0)</code></pre><p>咦，怎么canvas上啥都没有啊？这个api我用错了吗？后来我发现我确实用错了。后两个参数代表的点是文字的左下角而不是左上角。这也很可以理解，因为绘制文字的时候总是以下方的线进行对齐绘制的。</p>
<h2 id="canvas-的字体"><a href="#canvas-的字体" class="headerlink" title="canvas 的字体"></a>canvas 的字体</h2><p>为了让邀请函比较好看，当然是要对字使用某些比较好看的字体啦。但是，我却发现我设置的字体参数没有任何效果。</p>
<p>咦？不会呀，我明明已经用 font-face 定义了这些字体了啊。到底问题在哪里呢？我打开调试器发现，字体文件竟然都没有被下载？？？那一定是我 font-face 的定义格式写错了？</p>
<p>最后发现并非如此，浏览器会对字体进行懒加载，只有当实际使用这个字体的时候才会下载字体文件。所以说只定义 font-face 就在 canvas 中使用这个字体是没有效果的，因为这个字体文件都没有下载呢。这时候有两个办法：</p>
<ol>
<li>在 DOM 中事先使用一次这个字体，让这个字体文件先加载了。这种方法有比较大的限制。需要保证在 canvas 中使用这个字体的时候字体文件已经加载完成了。</li>
<li>使用 JS 来加载这个字体。话不多说上代码</li>
</ol>
<pre><code>// 像font-face中一样定义这个字体
const font = new FontFace(&quot;Arial&quot;, &quot;url(Arial.woff)&quot;, { style: &quot;normal&quot;, weight: 700 })
// 下载字体
font.load()
  .then(function(loadedFace) {
    // 把定义的字体加入文档流
    document.fonts.add(loadedFace)
  }).catch(function(error) {
    // error
  })</code></pre><ol start="3">
<li>有一个字体加载的回调函数：</li>
</ol>
<pre><code>document.fonts.ready.then(function(fontFaceSet) {
    // all fonts have been loaded
})</code></pre><h2 id="获取文字的高度"><a href="#获取文字的高度" class="headerlink" title="获取文字的高度"></a>获取文字的高度</h2><p>由于要计算文字放置的位置，所以就需要获取文字的宽高。这时候就找到了 <code>measureText</code> 这个 api 了。但是之后才发现，这个 api 并不能获取文字的高度，只能获取宽度。</p>
<p>经过查找，发现并不存在直接获取高度的api。准确的说，没有兼容度良好的获取高度的api。</p>
<pre><code>const metrics = ctx.measureText(text)
// 字体的高度，无论使用哪个字
const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent
// 某一个字的实际高度
const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent</code></pre><p>通过 caniuse 查看兼容度发现，Chrome 要版本 87 后才支持。Firefox和Edge默认不支持，需要设置某些特殊的实验属性才能支持。Safari要版本14才开始支持。</p>
<p>网上常见的方法都是一些比较hack的方法。主要思路就是手动构造一段这个文字。然后测量这段文字的高度。测量的方式一种是在DOM中构造用JS进行测量，还有一种是在canvas中作图，转化成图片，根据图片的像素点进行测量。</p>
<h2 id="绘制文字的参数"><a href="#绘制文字的参数" class="headerlink" title="绘制文字的参数"></a>绘制文字的参数</h2><p>这个很容易注意到，就提一句。当你绘制了一段文字后，要注意重置那些参数，否则下一段文字将要继续使用这些参数。</p>
<h2 id="canvas-绘制层级"><a href="#canvas-绘制层级" class="headerlink" title="canvas 绘制层级"></a>canvas 绘制层级</h2><p>由于图片加载是异步的，所以如果用同步的方式写代码图片总是后与文字画的。也就是说图片会叠加在文字之上。当时我想偷懒不想写异步代码，所以很自然想到 canvas 中会不会有类似 css 中 z-index 的属性。结果发现是不存在的，层级只能由绘制的先后关系决定。</p>
<h2 id="canvas-撤销操作"><a href="#canvas-撤销操作" class="headerlink" title="canvas 撤销操作"></a>canvas 撤销操作</h2><p>画上一张图，一段文字后生成了一张邀请函。这时候我就想要撤销写文字的操作。由于印象中 canvas 有 save 和 restore 的 api，就直接尝试了一下，发现不起作用。这时候我才知道 save 保存的是画布的坐标状态，而不是画布的全部状态。我又尝试找了一下canvas中撤销该怎么实现，发现并没有简单的实现方法。我看到的一共有以下几种方法：</p>
<ol>
<li>记录一个操作栈，撤销后就把canvas清空，然后把之前的操作重复一遍。当步数过多的时候就可能存在性能问题</li>
<li>同样是记录一个操作栈，每次进行操作的时候，都记录一下要回撤这个操作所需要的操作是什么。这个比较难以实现，很难用程序写出所有的撤销应该怎么做。</li>
<li>记录一个 canvas 状态的栈，每一次都把canvas当前图片保存下来。当步数过多时会占用很大的内存。</li>
</ol>
<p>所以还是需要根据程序的实际情况来做撤销的实现。当然我这里就直接清空重新画一遍是最方便的。</p>
<h2 id="canvas-图片下载"><a href="#canvas-图片下载" class="headerlink" title="canvas 图片下载"></a>canvas 图片下载</h2><p>当邀请函生成后我就想要下载邀请函的图片了。我使用了 <code>toDataURL</code> 这个 api。然后把他放到一个HTML的链接标签 a 的 src 属性中。然后调用元素的 click 方法模拟点击进行下载。但是没想到下载的东西报了一个网络错误。经过调查，发现是因为某些浏览器中对于src属性中的值的长度有限制，如果太长就无法正常下载。为了解决这个问题，我找到了以下两个方法。</p>
<ol>
<li><p>减小图片体积：toDataURL 这个 api 的第一个参数是 MIME 类型。这时候我们可以将其指定为 image/jpeg 来压缩图片的体积。如果这还不够，toDataURL 的第二个参数是图片的压缩程度。我们可以使用 <code>toDataURL(&quot;image/jpeg&quot;, 0.5)</code> 来继续缩小图片体积。</p>
</li>
<li><p>使用 blob 来进行下载。</p>
</li>
</ol>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/canvas/Canvas-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-优化webpack打包时间">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/webpack/%E4%BC%98%E5%8C%96webpack%E6%89%93%E5%8C%85%E6%97%B6%E9%97%B4/">优化webpack打包时间</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-12-07
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>在开发一个项目的时候，一开始webpack进行编译的速度都是很快的，因为我们引入的依赖很少。但是，当你的项目越来越臃肿的时候，打包的时间将大幅度的上升，有时候达到几分钟这种完全不能接受的地步。这时候，我们就应该开始着手对于webpack的打包流程进行优化了。</p>
<ol>
<li>分析依赖</li>
</ol>
<p>想要知道什么东西影响了打包的时间，那么我们当然需要了解我们打包出来的文件的构成。是哪些依赖导致的我们打包速度变慢。这时候，我们就要用到 webpack-bundle-analyzer 这个插件了。在使用了这个插件后，会自动打开一个网页，里面的图片就是我们打包结果的构成。如下图所示。</p>
<p><img src="https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-12-14%20002309%20%281%29.png?Expires=1607880388&OSSAccessKeyId=TMP.3Kk17ATZT8SrodLCzaxq2K4KsDXf7CogQeahPaTN9Nne1XCEwLVvNd8QbT9dWiytBkexfRVF7MptsxWDHDpnjhitAMQp9i&Signature=S7Lek%2FUnHyxEQuRLRrtgsw1UZhE%3D&versionId=CAEQDRiBgICSitnzshciIDc0Y2YxNTg2NTg3ZDRlZTNiMjhmN2U1ZDQzYWViMjMy&response-content-type=application%2Foctet-stream" alt=""></p>
<p>显而易见的，我们可以发现，element 和 echarts 这两个库占用了大量的体积，我们可以对此进行优化。</p>
<p>上面的插件是用来分析每个依赖的体积的。但是，我们要关心的不止是体积，我们关注点的根源应该是时间。所以，我们需要一个东西来分析所有的依赖打包所花的时间。这时候，我们就要用到 speed-measure-webpack-plugin 这个东西了。这个东西的引入也很简单。</p>
<pre><code>// webpack file
const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;)
const smp = new SpeedMeasurePlugin()

module.exports = smp.wrap(webpackConfig)</code></pre><p>使用如上所示的代码把 webpack 配置包裹在这个函数中即可。</p>
<p>最后，我们运行命令进行打包可以看到如下图所示的结果。他们分别列出了每一个loader运行所花的时间。我们可以针对这些数据进行各自优化。</p>
<p><img src="https://floatdai-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-12-14%20004832%20%281%29.png?Expires=1607881788&OSSAccessKeyId=TMP.3Kk17ATZT8SrodLCzaxq2K4KsDXf7CogQeahPaTN9Nne1XCEwLVvNd8QbT9dWiytBkexfRVF7MptsxWDHDpnjhitAMQp9i&Signature=K0HZByEYACZvDny67JF1A5PQ%2BBA%3D&versionId=CAEQDRiBgMDU9YL0shciIDBhMTgzYjA3YzA4YjQ2MzNiMzNhNDQ5MThkODA0YWM1&response-content-type=application%2Foctet-stream" alt=""></p>
<ol start="2">
<li>cache-loader</li>
</ol>
<p>说到优化打包时间，那么我们第一时间想到的就是利用缓存，利用空间换时间了。第一次打包时在磁盘中存储一些打包后的结果，之后每次打包都可以利用这个结果那是极好的了。</p>
<p>cache-loader 就是用来做这件事情的东西。不过,第一次打包的时候可能要划更多的时间，因为需要打包一些需要缓存的内容。第二次之后就可以使用这些缓存的内容加快打包速度了。</p>
<p>配置他很简单，把他放在其他loader之前即可。</p>
<pre><code>{
  test: /\.vue$/,
  use: [
    &quot;cache-loader&quot;,
    &quot;vue-loader&quot;,
  ],
}</code></pre><p>我们仍然使用之前的项目进行测试。我们对于其中标红的两个包，babel-loaer 和 vue-loader 分别都配置了 cache-loader。第一次打包花了78s，第二次打包花了60s。</p>
<p>而当我们不使用 cache-loader 的时候则花了77s。</p>
<p>可以看到，使用了 cache-loader 后，第二次开始的打包时间有了明显的提升。</p>
<ol start="3">
<li>HardSourceWebpackPlugin</li>
</ol>
<p>HardSourceWebpackPlugin 同样是一个使用缓存来进行加速打包的一个插件。他的缓存默认被存在 /.cache/hard-source 文件夹中。第一次打包他将花费更多的时间以用于进行缓存。第二次打包则有显著的速度提升。</p>
<p>我们通用使用之前的项目进行测试。第一次打包花了149秒，第二次打包花了45秒。相比于cache-loader的时间有了不小的提升。</p>
<p>我们再尝试一下同时使用 cache-loader 和 HardSourceWebpackPlugin 进行打包。第一次打包花了156秒，第二次打包花了44秒。和单独使用 HardSourceWebpackPlugin 打包的速度并没有什么区别。</p>
<p>当然，在配置这个插件的时候还是有很多坑的。这些在这个插件的 README 中的 <a href="https://www.npmjs.com/package/hard-source-webpack-plugin#troubleshooting" target="_blank" rel="noopener">troubleshooting</a>都有提到。</p>
<ol start="4">
<li>external</li>
</ol>
<p>external 是 webpack 中的一个配置项。这个配置项的功能是在打包的时候不对某些包进行打包。而是通过 CDN 的方式来引入这些包。这就是通过减少打包的内容来提高打包的时间的一种配置。</p>
<p>示例配置如下。</p>
<pre><code>// in webpack config
external: {
  jquery: &quot;jQuery&quot;,
}

// in code
import $ from &quot;jquery&quot;</code></pre><p>这时候，这个 $ 就相当于引入 jQuery 了。</p>
<ol start="5">
<li>webpack dll</li>
</ol>
<p>dll 是 Windows 中的一个概念。这里用维基百科上话来解释一波。</p>
<blockquote>
<p>所谓动态链接，就是把一些经常会共享的代码（静态链接的OBJ程序库）制作成DLL档，当可执行文件调用到DLL档内的函数时，Windows操作系统才会把DLL档加载存储器内，DLL档本身的结构就是可执行档，当程序有需求时函数才进行链接。通过动态链接方式，存储器浪费的情形将可大幅降低。静态链接库则是直接链接到可执行文件。<br>DLL的文件格式与视窗EXE文件一样——也就是说，等同于32位视窗的可移植执行文件（PE）和16位视窗的New Executable（NE）。作为EXE格式，DLL可以包括源代码、数据和资源的多种组合。<br>在更广泛的意义上说，任何同样文件格式的电脑文件都可以称作资源DLL。这样的DLL的例子有扩展名为ICL的图标库、扩展名为FON和FOT的字体文件。</p>
</blockquote>
<p>所以，其实 dll 其实也是一种缓存的形式。在 webpack 中，他的使用方式是事先把一些第三方的库打包成一个个dll文件，在打包的时候就可以跳过这些文件进行打包。直接使用这些文件代码即可运行。</p>
<p>让我们来看看怎么使用这个东西。</p>
<p>首先要有一个生成 dll 文件的配置文件。</p>
<pre><code>const vendors = [
  &quot;vue&quot;,
  &quot;vue-router&quot;,
  &quot;vuex&quot;,
]

module.exports = {
  entry: {
    vendor: vendors,
  },
  output: {
    path: path.resolve(__dirname, &quot;../dll&quot;),
    filename: &quot;[name]_[fullhash].js&quot;,
    library: &quot;[name]_[fullhash]&quot;,
  },
  plugins: [
    new webpack.DllPlugin({
      context: path.resolve(__dirname, &quot;../&quot;),
      name: &quot;[name]_[fullhash]&quot;,
      path: path.join(__dirname, &quot;manifest.json&quot;),
    })
  ],
}</code></pre><p>使用 webpack 运行上面的配置文件即可生成 dll 文件。生成的 dll 文件全都生成在了 dll 文件夹中。输出的配置文件则是 manifest.json</p>
<pre><code>new webpack.DllReferencePlugin({
  context: path.resolve(__dirname, &quot;../&quot;),
  manifest: path.resolve(__dirname, &quot;manifest.json&quot;),
})</code></pre><p>想要使用的这些 dll 文件只要在 webpack 配置中的 plugin 加上一个新的 plugin 即可。在里面配置一下之前生成的 dll 输出的配置文件 manifest.json 即可。</p>
<ol start="6">
<li>开启多进程</li>
</ol>
<ul>
<li><p>terser-webpack-plugin 可以开启多进程选项。这是一个压缩JS代码的差距。</p>
</li>
<li><p>thread-loader: 对于那些比较耗时的loader可以配置一下 thread-loader 开启多进程。配置也非常简单，只要把他放在想要配置的loader之前即可。但是进程的启动是需要时间的，所以最好只在耗时的loader上配置 thread-loader。否则可能会话更多的时间。</p>
</li>
</ul>
<ol start="7">
<li>webpack 5</li>
</ol>
<p>每次webpack 的升级都带来了打包性能不小的提升，所以升级你的webpack，一定可以得到不小的惊喜。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/webpack/%E4%BC%98%E5%8C%96webpack%E6%89%93%E5%8C%85%E6%97%B6%E9%97%B4/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-stylus 变量管理">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/uncategorized/stylus-%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86/">stylus 变量管理</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-29
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/stylus/" class="cube-excerpt-tag-link">#stylus</a>
                
                <a href="/tags/css/" class="cube-excerpt-tag-link">#css</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>这两天刚刚启动一个新项目，正好有一点时间来思考一些项目整体上的东西。其中我就遇到了一个问题。我们在使用 stylus 的时候，会定义一些变量，用这些变量来写css。比如说<code>$font-base = 14px</code>。但是，如果我们在 JS 中想要使用这个字体的大小，以前我只会直接在代码里面写一个14。再好一点，在函数中定义一个变量<code>const FONT_BASE = 14</code>。或者再开一个专门的文件来定义 JS 中使用的 stylus 的变量，用的时候再引入。</p>
<p>但是，这样的话是违背代码书写的原则的。既然 stylus 的变量定义和 JS 中我们使用的变量是同一个东西，那么，我们当然也希望可以使用一个文件就可以管理 stylus 变量的定义。</p>
<p>经过我的寻找，我发现 stylus 中确实存在这样一个方法来实现这个目标。</p>
<p>那就是 stylus 的 json 函数。具体的文档位置为 <a href="https://stylus-lang.com/docs/bifs.html#jsonpath-options" target="_blank" rel="noopener">stylus json函数</a></p>
<p>我们可以把想要定义的 stylus 变量都先定义在一个 JSON 文件中，然后我们可以在 stylus 文件中使用 json 函数进行引入。而当我们想在 JS 中使用这些变量，也可以通过这个 JSON 文件引入。这样就实现了同一个文件来管理 stylus 变量的方法。我们看一个例子。</p>
<pre><code>// variable.json
{
  &quot;$main&quot;: &quot;#234235&quot;,

  &quot;$font&quot;: {
    &quot;base&quot;: &quot;14px&quot;,
    &quot;medium&quot;: &quot;16px&quot;
  }
}</code></pre><pre><code>// variable.styl
json(&quot;./variable.json&quot;)</code></pre><p>这样做相当于在 variable.styl 文件中做了如下定义。</p>
<pre><code>$main = #234235
$font-base = &quot;14px&quot;
$font-medium = &quot;16px&quot;</code></pre><p>我们可以看到，对象的 key 和 value 分别作为了变量名和变量的值。如果有嵌套的多层对象，那么对象将被全部展开到最底层，每一层的 key 将以中划线的形式进行连接。这就是 json 函数的使用方法。</p>
<p>有了这个方法，我们就可以实现之前提到的目标，在同一个文件中管理 stylus 变量在 CSS 和 JS 中的使用。</p>
<p>stylus 还是有很多高级的功能可以使用的，只不过我们平时只是常用他最基础的那些功能而已。在看 json 这个函数的文档的时候，我向下翻了一下，看到了<a href="https://stylus-lang.com/docs/bifs.html#usepath" target="_blank" rel="noopener">use 函数</a>。这个函数的作用是可以自定义一些新的函数，让 stylus 编译器可以识别这些函数。这就给了我们开发者很大的自由度，让我们可以实现一些骚操作。具体的使用方式还是见文档吧。但是这个文档写的不太仔细，详细使用方法说的不是很确切，有时间我可以再研究一下。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/uncategorized/stylus-%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-canvas中的图片跨域问题">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/uncategorized/canvas%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">canvas中的图片跨域问题</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-23
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/canvas/" class="cube-excerpt-tag-link">#canvas</a>
                
                <a href="/tags/%E8%B7%A8%E5%9F%9F/" class="cube-excerpt-tag-link">#跨域</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>canvas的图片跨域问题是指，当在canvas中使用和当前网站不同域名的图片资源的时候，如果你想使用canvas的<code>toDataURL</code>等转化成实际图片进行处理，比如下载。这时候你会发现跨域的图片的那部分将无法加载出来。</p>
<p>这种事情是非常常见的，因为我们很多情况下并不会把图片资源和网页挂在同一个域名下。当然，你也可以对某些子路径的域名做一层反代规避掉这个问题。如果你没有做这个，那么你应该怎么办呢？</p>
<p>这时候你就需要做两件事：</p>
<ol>
<li><p>首先在你存放文件的地方，如果是在腾讯云或者阿里云这种，直接设置图片的跨域头。也就是加上<code>Access-Control-Allow-Origin: ${ your domain }</code>的跨域头。当然如果你嫌麻烦，跨域直接把<code>${ your domain }</code>这一部分写成*，这样任何网页都可以使用你的图片。</p>
</li>
<li><p>然后在 img 标签上添加一个属性,有两种方法添加</p>
<ul>
<li><p>通过js添加，也就是在那个img标签中做如下操作</p>
<pre><code>const image = new Image()
image.crossOrigin = &quot;anonymous&quot;
image.src = &quot;url&quot; // set a true url</code></pre></li>
<li><p>直接在HTML代码中添加</p>
<pre><code>&lt;img src=&quot;url&quot; crossorigin=&quot;anonymous&quot; /&gt;</code></pre></li>
</ul>
</li>
</ol>
<p>但是，以上的解决方法都是在图片的控制权在你的手上的情况下。如果这是一张第三方的图片，你就无法设置他的跨域头来解决问题了。就比如产品希望我在canvas上画上一个微信生成的二维码。我不是马化腾，没有能力让腾讯的工程师给我加一个跨域头。所以这种情况下，也有两个办法：</p>
<ol>
<li>让后端的同学们帮忙开一个接口，下载那个图片。后端的接口是可以控制的。</li>
<li>通过nginx设置反代来获取那张图片，并且在nginx中加入设置跨域头的配置。</li>
</ol>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/uncategorized/canvas%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-JS正则bug">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/js/JS%E6%AD%A3%E5%88%99bug/">JS正则bug</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-10-11
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/js/" class="cube-excerpt-tag-link">#js</a>
                
                <a href="/tags/%E6%AD%A3%E5%88%99/" class="cube-excerpt-tag-link">#正则</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>让我们来看一段代码</p>
<pre><code>const reg = /\d/g
console.log(reg.test(&quot;1&quot;)) // true
console.log(reg.test(&quot;1&quot;)) // false
console.log(reg.test(&quot;1&quot;)) // true
console.log(reg.test(&quot;1&quot;)) // false</code></pre><p>这时我们会发现，有两次正则的 test 方法得出的结果是错误的。这是什么原因呢？让我们再看几段代码。</p>
<pre><code>const reg = /\d/
console.log(reg.test(&quot;1&quot;)) // true
console.log(reg.test(&quot;1&quot;)) // true</code></pre><pre><code>console.log(/\d/g.test(&quot;1&quot;)) // true
console.log(/\d/g.test(&quot;1&quot;)) // true</code></pre><p>我们可以看到，我们换了两种写法，这个 bug 就不再出现了。一个是去掉了正则的 g 这个 flag。一个是不再使用定义的正则常量，而是每次都使用新的正则实例。显然，这个 bug 出现的原因就在与这个正则常量以及 g 这个 flag 身上。让我们再看一段代码。</p>
<pre><code>const reg = /\d/g
console.log(reg.lastIndex) // 0
console.log(reg.test(&quot;1&quot;)) // true
console.log(reg.lastIndex) // 1
console.log(reg.test(&quot;1&quot;)) // false
console.log(reg.lastIndex) // 0
console.log(reg.test(&quot;1&quot;)) // true
console.log(reg.lastIndex) // 1
console.log(reg.test(&quot;1&quot;)) // false
console.log(reg.lastIndex) // 0</code></pre><p>我们可以看到，这个正则常量有一个叫做 lastIndex 的属性，这个属性是在正则使用了 g 这个 flag 的时候才会有作用。用处是记录上一次正则匹配的结果的索引值 +1，匹配失败则返回0。这样存在 g 这个 flag 的正则可以进行多次匹配。让我们来看一段代码来体会他的作用。</p>
<pre><code>const reg = /\d/g
console.log(reg.exec(&quot;12&quot;)) // [&quot;1&quot;, index: 0, input: &quot;12&quot;, groups: undefined]
console.log(reg.exec(&quot;12&quot;)) // [&quot;2&quot;, index: 1, input: &quot;12&quot;, groups: undefined]
console.log(reg.exec(&quot;12&quot;)) // null</code></pre><p>在使用正则进行多次匹配的时候，就是 lastIndex 这个属性记录的上一次匹配的位置，并告诉你他下次开始匹配的位置的索引值。我们也可以修改 lastIndex 来改变。</p>
<pre><code>const reg = /\d/g
console.log(reg.exec(&quot;12&quot;)) // [&quot;1&quot;, index: 0, input: &quot;12&quot;, groups: undefined]
reg.lastIndex = 0
console.log(reg.exec(&quot;12&quot;)) // [&quot;1&quot;, index: 0, input: &quot;12&quot;, groups: undefined]</code></pre><p>可以看到，这时候又从头开始匹配了。在我们平时的业务代码中，有时候经常会需要一个类型的正则，就比如说检查输入的数字是否是合法的金额，并且在好几个地方都会用到这个正则。这种情况下我们可能就会定义一个常量来储存这个通用的正则。所以我们平时要小心这个问题。</p>
<p>但是，在我们的第一段代码中，显然这种结果不是我们所预期的。这显然是可以称为一个 bug 的。想要避开这个问题，一共有三种解决方法。</p>
<pre><code>/\d/g.test(&quot;1&quot;)</code></pre><p>第一种我认为是最好的，可以最优雅的解决这个问题。就是每次用正则的时候都使用新的实例，不要定义常量。</p>
<pre><code>cosnt reg = /\d/
reg.test(&quot;1&quot;)</code></pre><p>第二种就是不使用 g 这个 flag 就不会触发 lastIndex 的问题。但是有时候我们确实会需要 g 这个 flag，并不一定能完美的解决问题。</p>
<pre><code>const reg = /\d/g
reg.test(&quot;1&quot;)
reg.lastIndex = 0</code></pre><p>第三种就是每次使用过之后，都将 lastIndex 属性重置为 0。这个方法就不是非常优雅。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/js/JS%E6%AD%A3%E5%88%99bug/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-JS 异步陷阱">
    <header class="cube-excerpt-header">
        <h1><a href="/blog/uncategorized/JS-%E5%BC%82%E6%AD%A5%E9%99%B7%E9%98%B1/">JS 异步陷阱</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-10-04
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>今天在写代码的时候 linter 报了一个错，名字是 <code>require-atomic-updates</code> 的错误。具体的代码形势如下。</p>
<pre><code>let _db = {}
async function a() {
  _db.contract = (await axios.get(&quot;/api/contracts/info&quot;)).data
}</code></pre><p>我乍一看，这种基础的代码还能有什么规范错误的吗？最后，我发现，其实 eslint 期望检查出的是这种类型的错误。</p>
<pre><code>let a = 0
function setA(value) {
  a += (await axios.get(&quot;/api/contracts/info&quot;)).data
}</code></pre><p>这种情况下，JS 会记住a的值，如果在这个异步过程中a的值被其他东西改变了，那么将得到错误的结果。</p>
<p>在 GitHub 上有一个关于这个问题的 issue： <a href="https://github.com/eslint/eslint/issues/11899" target="_blank" rel="noopener">require-atomic-updates false positive</a></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/blog/uncategorized/JS-%E5%BC%82%E6%AD%A5%E9%99%B7%E9%98%B1/">Read More</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-6">
    
    <li class="cube-pagination-prev disabled">
        <span>« Prev</span>
    </li>
    
    
        
            
            <li class="cube-pagination-index disabled">
                <span>1</span>
            </li>
            
        
            
            <li class="cube-pagination-index">
                <a href="/page/2">2</a>
            </li>
            
        
            
            <li class="cube-pagination-index">
                <a href="/page/3">3</a>
            </li>
            
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/2/">Next »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>Yifei Dai</span>
    
    
    <div class="count">
        <a class="count articles"><span>21</span>Article</a>
        <a class="count tags"><span>28</span>Tags</a>
        <a class="count categories"><span>7</span>Categories</a>
    </div>
</div>





<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/blog/uncategorized/yarn/" title="yarn">yarn</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/blog/js/webpack5%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/" title="webpack5迁移记录">webpack5迁移记录</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/blog/uncategorized/wsl2%E8%B8%A9%E5%9D%91/" title="wsl踩坑">wsl踩坑</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/blog/uncategorized/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="JS垃圾回收机制">JS垃圾回收机制</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/blog/canvas/Canvas-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/" title="Canvas 的几个坑">Canvas 的几个坑</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/CSS/">#CSS</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/git/">#git</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/canvas/">#canvas</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/HTML/">#HTML</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/js/">#js</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/code/">#code</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/webpack/">#webpack</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box-bg ">
            <a href="/tags/CSS/">#CSS</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/CSS-Variables/">#CSS Variables</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/git/">#git</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/canvas/">#canvas</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Hugo/">#Hugo</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Vue/">#Vue</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/AMD/">#AMD</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/CMD/">#CMD</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/UMD/">#UMD</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/ES6-MODULE/">#ES6 MODULE</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/webpack/">#webpack</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/js/">#js</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/%E6%AD%A3%E5%88%99/">#正则</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/JS/">#JS</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/unicode/">#unicode</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/utf-8/">#utf-8</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/stylus/">#stylus</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/css/">#css</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E8%B7%A8%E5%9F%9F/">#跨域</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Web-Component/">#Web Component</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/SVG/">#SVG</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/yarn/">#yarn</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Plug-n-Play/">#Plug&#39;n&#39;Play</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Zero-Installs/">#Zero-Installs</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/AST/">#AST</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/CSS-in-JS/">#CSS in JS</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/CSS-module/">#CSS module</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/BEM/">#BEM</a>
        </div>
        
    </div>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 Yifei Dai

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>