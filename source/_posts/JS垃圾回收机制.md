---
title: JS垃圾回收机制
date: 2021-01-11 01:51:34
tags:
  - JS

catogories:
  - JS
---

有些语言，比如C语言，是需要程序员手动申请和释放内存的，这增加了程序员的心智负担。大多数语言都提供了自动的垃圾处理机制。JS也同样如此。

## 垃圾回收机制

JS 垃圾回收机制的根本就是判断一个变量是否可以被访问到。如果一个变量不可以从根上开始，由某种路径访问到的话，那么这个变量就是不可被访问的。这种情况下，JS引擎就认为这个变量是可以被垃圾回收的。

```
function a() {
  const f = {}
}

function b() {
  const g = {}
  return g
}

const d = a()
const e = b()
```

简单的举一个例子。我们看一下上述代码。

在执行a函数期间，变量f始终存在，因为f可以在当前的上下文环境，也就是a函数中被访问到。但是当a函数执行结束，我们的上下文环境变成了全局，这时候我们就无法通过任何方式访问到f变量了。这时候JS引擎就把e变量给释放掉了。

在执行b函数期间，变量g始终存在，因为g可以在当前的上下文环境，也就是b函数中被访问到。当b函数执行结束，将g作为返回值赋值给了e，所以即使上下文环境切换了，但是我们仍然可以通过变量e来访问变量g，所以变量g并不会被回收。

一般垃圾回收的算法是通过 标记-清除 来实现的。垃圾回收期会定时的执行这些任务。

1. 获取根并标记。 也就是我们的全局环境。
2. 标记所有根可以访问到的引用。 也就是全局变量，以及各个代码块形成的局部环境。
3. 标记上一步标记的引用可以访问到的引用，并不断重复这一步，直到没有新的未被标记的变量出现为止。
4. 回收所有没有被标记到的变量。

## 内存泄露的原因

1. 全局变量

由于全局变量是直接存在根环境之中的，所以显然他是在任何情况下都不会被回收的。我们要尽可能少的使用全局变量。

当然有时候我们会无意中使用了全局变量，如下所示：

```
function a() {
  b = 1
}
```

在上述代码中，变量 b 将作为一个全局变量进行定义。这显然是我们不希望的。当然，现在使用linter或者开启JS的严格模式都很容易可以避免这个问题的发生。

2. 闭包

在某一个函数执行完后，照理这个函数环境下定义的变量都将要被回收，但是有一个情况是例外的，那就是闭包。

在闭包的情况下，函数中的那个变量将可以被外界所访问到，所以显然是不能被回收的。

3. 忘记结束的定时器

```
setInterval(function a() {

}, 1000)
```

这个函数a将用于不会被回收，因为这个定时器将一直被执行，所以显然不能被回收，所以我们要记住结束定时器。

```
window.addEventListener("click", function a() {

})
```

同样的，这种监听器也是如此。不能忘记 `removeEventListener`。

4. 被移除的DOM

大家在操作DOM的时候，有些DOM节点可能会被多次使用。这时候，我们会考虑把DOM的查询结果存在一个变量之中。因为我们都知道，DOM和JS引擎是互相独立的，JS要操作DOM是很耗性能的。那么如果之后我们把这个DOM移除了，这个DOM节点其实并没有被回收，因为他还被一个变量所引用了。

5. console.log

被 console.log 所打印的变量是不会被回收的。这也很好理解，因为我们要随时可以去 console 里面看这个变量，所以当然不能被回收。所以在生产环境中，我们要尽量避免使用 console.log。一般生产环境的打包都有自动移除 console 的选项。

## 如何发现内存泄露（待补图）

首先第一步是要确定是否存在内存泄露的现象。我们可以靠 Chrome 提供的调试工具来做到这个。

1. 首先按 F12 打开 Chrome 的调试面板。
2. 点击跳转到 Performance 这个 tab。
3. 点击左上方的实心小圆球，hover 上去显示的是 record 的那个。点击这个将开始记录之后的各种性能问题的参数。
4. 进行一些认为存在性能问题的操作。
5. 点击 Stop 按钮。结束记录。

在最上面，我们可以看到 FPS，CPU，NET，HEAP 这四个性能指标的图表图表。内存问题的话可以看 HEAP 这个。如果他的趋势是一直上升那显然就存在内存泄露。

详细的内容也可以给 ScreenShots 旁边的 Memory 打钩（注意不是和 Performance 同级的那个，在下一行中），打开这个新的面板。可以看到内存随着时间的使用详情。

但是这个工具只能记录一段时间的使用情况。Chrome 有一个工具，名字叫 Performance Monitor 可以实时的监控各种性能指标的使用情况。打开方式如下：

1. 点击调试工具最上方的最右边的 X 左边的三个点，会弹出一个 context menu
2. 鼠标悬浮到这个弹出的菜单的 More tools 上，会再延伸出一个子菜单
3. 点击子菜单中的 Performance Menu，将在最下方弹出 Performance Menu 菜单

我们可以看到，这个菜单中有 CPU usage， JS heap size， DOM Nodes 等众多性能指标，并且在实时的进行记录。通过这个工具，我们可以更加方便的进行性能分析。

最后，我们就要分析到底是什么导致了内存泄露。

这时候，我们就要点开最上面的 Memory 这个 tab 了。

点开这个菜单后，点击左上角的小圆球（hover上去显示 Take heap snapshot）。点击这个后将生成一个那个时刻的内存使用情况的快照。我们可以生成多份快照，来比较不同时间之间内存使用的变化来分析哪里发生了内存泄露。当然，我们也可以点击那个垃圾桶的图标，来进行手动的触发垃圾回收。再生成新的快照来比较内存使用情况进行分析。

再让我们点开一份快照，看看里面有哪些信息。我们可以看到，他分成了两个窗口，上面有很多条目，下面的标题是 Retainer（可以理解成定位器），但是空无一物。

观察一下这些条目，发现有

- array
- closure
- compiled code
- concatenated string
- number
- regexp
- ...

可以看到，他把内存的使用情况进行分类的整理。随便点开一个类型，可以看到很多“变量”。他们都各自在当前实际占用了一部分内存。点击选中一个“变量”，我们可以发现，底下的那个 Retainer 窗口有值了。显示出来的是一个嵌套的结构。注意，这个嵌套结构是反的。这个嵌套的结构展示了，这个变量是如何通过root来访问到他的。也就是说最上层是自己，下层就是他自己的上级。这个结构就展示了为什么这个变量没有被回收。而且，更方便的是，在每一层的右边，有一个代码的链接，可以让你迅速的找到创建这一层上下文或者变量的代码的位置。

通过对这两个窗口进行分析，我们可以比较清楚的定位到发生内存泄露的位置了。
