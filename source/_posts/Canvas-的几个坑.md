---
title: Canvas 的几个坑
date: 2020-12-28 00:03:02
tags:
  - canvas
categories:
  - canvas
---

最近接到公司的一个临时需求，要生成一批不同名字的邀请函。一开始我觉得这实在是太简单了，不就是canvas上贴一张图再写名字就结束了吗？但是没想到，因为不熟悉canvas导致这其中好几个坑花了我好多时间。

## fillText 参数

接到这个需求，上来肯定是先去看看写字的api喽。然后我就开始测试一下。

```
ctx.fillText("hello", 0, 0)
```

咦，怎么canvas上啥都没有啊？这个api我用错了吗？后来我发现我确实用错了。后两个参数代表的点是文字的左下角而不是左上角。这也很可以理解，因为绘制文字的时候总是以下方的线进行对齐绘制的。

## canvas 的字体

为了让邀请函比较好看，当然是要对字使用某些比较好看的字体啦。但是，我却发现我设置的字体参数没有任何效果。

咦？不会呀，我明明已经用 font-face 定义了这些字体了啊。到底问题在哪里呢？我打开调试器发现，字体文件竟然都没有被下载？？？那一定是我 font-face 的定义格式写错了？

最后发现并非如此，浏览器会对字体进行懒加载，只有当实际使用这个字体的时候才会下载字体文件。所以说只定义 font-face 就在 canvas 中使用这个字体是没有效果的，因为这个字体文件都没有下载呢。这时候有两个办法：

1. 在 DOM 中事先使用一次这个字体，让这个字体文件先加载了。这种方法有比较大的限制。需要保证在 canvas 中使用这个字体的时候字体文件已经加载完成了。
2. 使用 JS 来加载这个字体。话不多说上代码

```
// 像font-face中一样定义这个字体
const font = new FontFace("Arial", "url(Arial.woff)", { style: "normal", weight: 700 })
// 下载字体
font.load()
  .then(function(loadedFace) {
    // 把定义的字体加入文档流
    document.fonts.add(loadedFace)
  }).catch(function(error) {
    // error
  })
```

3. 有一个字体加载的回调函数：

```
document.fonts.ready.then(function(fontFaceSet) {
	// all fonts have been loaded
})
```

## 获取文字的高度

由于要计算文字放置的位置，所以就需要获取文字的宽高。这时候就找到了 `measureText` 这个 api 了。但是之后才发现，这个 api 并不能获取文字的高度，只能获取宽度。

经过查找，发现并不存在直接获取高度的api。准确的说，没有兼容度良好的获取高度的api。

```
const metrics = ctx.measureText(text)
// 字体的高度，无论使用哪个字
const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent
// 某一个字的实际高度
const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
```

通过 caniuse 查看兼容度发现，Chrome 要版本 87 后才支持。Firefox和Edge默认不支持，需要设置某些特殊的实验属性才能支持。Safari要版本14才开始支持。

网上常见的方法都是一些比较hack的方法。主要思路就是手动构造一段这个文字。然后测量这段文字的高度。测量的方式一种是在DOM中构造用JS进行测量，还有一种是在canvas中作图，转化成图片，根据图片的像素点进行测量。

## 绘制文字的参数

这个很容易注意到，就提一句。当你绘制了一段文字后，要注意重置那些参数，否则下一段文字将要继续使用这些参数。

## canvas 绘制层级

由于图片加载是异步的，所以如果用同步的方式写代码图片总是后与文字画的。也就是说图片会叠加在文字之上。当时我想偷懒不想写异步代码，所以很自然想到 canvas 中会不会有类似 css 中 z-index 的属性。结果发现是不存在的，层级只能由绘制的先后关系决定。

## canvas 撤销操作

画上一张图，一段文字后生成了一张邀请函。这时候我就想要撤销写文字的操作。由于印象中 canvas 有 save 和 restore 的 api，就直接尝试了一下，发现不起作用。这时候我才知道 save 保存的是画布的坐标状态，而不是画布的全部状态。我又尝试找了一下canvas中撤销该怎么实现，发现并没有简单的实现方法。我看到的一共有以下几种方法：

1. 记录一个操作栈，撤销后就把canvas清空，然后把之前的操作重复一遍。当步数过多的时候就可能存在性能问题
2. 同样是记录一个操作栈，每次进行操作的时候，都记录一下要回撤这个操作所需要的操作是什么。这个比较难以实现，很难用程序写出所有的撤销应该怎么做。
3. 记录一个 canvas 状态的栈，每一次都把canvas当前图片保存下来。当步数过多时会占用很大的内存。

所以还是需要根据程序的实际情况来做撤销的实现。当然我这里就直接清空重新画一遍是最方便的。

## canvas 图片下载

当邀请函生成后我就想要下载邀请函的图片了。我使用了 `toDataURL` 这个 api。然后把他放到一个HTML的链接标签 a 的 src 属性中。然后调用元素的 click 方法模拟点击进行下载。但是没想到下载的东西报了一个网络错误。经过调查，发现是因为某些浏览器中对于src属性中的值的长度有限制，如果太长就无法正常下载。为了解决这个问题，我找到了以下两个方法。

1. 减小图片体积：toDataURL 这个 api 的第一个参数是 MIME 类型。这时候我们可以将其指定为 image/jpeg 来压缩图片的体积。如果这还不够，toDataURL 的第二个参数是图片的压缩程度。我们可以使用 `toDataURL("image/jpeg", 0.5)` 来继续缩小图片体积。

2. 使用 blob 来进行下载。
